<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Spike</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 2px;
            background-color: #ffffff;
            color: #000000;
            margin: 0;
        }

        .left-column {
            position: fixed;
            top: 0;
            left: 0;
            width: 80px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background-color: #f5f5f5;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
        }

        .emoji-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding-top: 12px;
            height: 100%;
            overflow-y: auto;
            width: 100%;
        }

        .emoji-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .emoji-container button {
            font-size: 32px;
            cursor: pointer;
            border: none;
            background: none;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .emoji-container button:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-label {
            margin-top: 1px;
            font-size: 12px;
            color: black;
            text-align: center;
            width: 70px;
            word-wrap: break-word;
        }

        .snippet-column {
            margin-left: 80px;
            padding: 0px 12px 12px 12px;
        }

        .snippet {
            border: none;
            border-radius: 8px;
            padding: 6px;
            margin: 8px 0;
            background-color: transparent;
            width: 100%;
            box-sizing: border-box;
        }

        .snippet button {
            cursor: pointer;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            color: #ffffff;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.12s ease, filter 0.12s ease;
        }

        .snippet button:hover {
            transform: scale(1.04);
            filter: brightness(110%);
        }

        .snippet .emoji {
            font-size: 1.3em;
            line-height: 1;
        }

        .snippet .label {
            font-size: 1em;
        }

        .release-info {
            text-align: center;
            margin-top: 400px;
            padding: 20px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
        }

        .emoji-container .color-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
            font-size: 0; /* Remove any text content */
        }

        .emoji-container .color-circle:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-container .blue-circle { background-color: #0066FF !important; }
        .emoji-container .light-blue-circle { background-color: #87CEEB !important; }
        .emoji-container .red-circle { background-color: #CC0000 !important; }
        .emoji-container .pink-circle { background-color: #FF69B4 !important; }
        .emoji-container .purple-circle { background-color: #8A2BE2 !important; }
        .emoji-container .yellow-circle { background-color: #FFD700 !important; }
        .emoji-container .dark-yellow-circle { background-color: #DAA520 !important; }
        .emoji-container .green-circle { background-color: #32CD32 !important; }
    </style>
</head>
<body>
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button class="color-circle purple-circle" onclick="refreshSnippets(1)"></button>
                <div class="emoji-label">Demos</div>
            </div>
        </div>
    </div>
    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>
    <div class="snippet-column">
        <div class="release-info" id="release-info">
            Â© 2024 Spike Editor - Loading release info...
        </div>
    </div>
    <script>
        const snippetData = {
            1: {  // Demos
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Line Follower Bang Bang',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    # set movement speed to 30%
    speed = int(0.3 * 1100)

    # set sleep seconds to 40 milliseconds 
    sleep_milliseconds = 40

    for i in range (300):
        if color_sensor.color(port.F) == color.BLUE and color_sensor.color(port.F) != -1:
            motor_pair.move(motor_pair.PAIR_1, 50, velocity=speed)
            sleep_ms(sleep_milliseconds)
        else:
            motor_pair.move(motor_pair.PAIR_1, -50, velocity=speed)
            sleep_ms(sleep_milliseconds)
    `
                    },
                    {
                        id: "fn2",
                        buttonText: 'Line Follow (Class)',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    # create robot object from LineFollow class    
    robot = LineFollow(target_light=70, speed=140, kp=6.5)






class LineFollow:
    """A robot that can follow a line.
    
    This robot uses a light sensor to see the edge between the dark and light and automatically steers
    the wheels to stay over the edge by adjusting the motor speeds.
   
    Attributes:
        target_light (int): The desired light intensity the robot tries to stay on.
            Defaults to 60.
        speed (int): How fast the robot moves.
            Defaults to 180.
        kp (float): Proportional gain for steering correction.
            Defaults to 6.8.

    Args:
        target_light (int): The desired light intensity the robot tries to stay on.
            Defaults to 60.
        speed (int): How fast the robot moves.
            Defaults to 180.
        kp (float): Proportional gain for steering correction.
            Defaults to 6.8.
           
    Example:
        Basic usage example:

            line_follower = LineFollow(target_light=60, speed=180, kp=6.8)
            
            # Parent code controls the loop
            for i in range(100):
                await line_follower.follow_line()

    Note:
        - Target_light is computed from half the difference between the value returned from the sensor when positioning over the light then over the dark. 
        - Higher speeds are mostly for competition runs. 
        - kp is the gain in a PID controller, higher gains makes the robot react more strongly to deviations from the target light level.
        """

    def __init__(self, target_light=70, speed=140, kp=6.5):
        self.target_light = target_light
        self.speed = speed
        self.kp = kp
        self.iteration = 0
    
    async def follow_line(self):
        """Execute one iteration of line following behavior.
        
        This method performs a single iteration of the line following control loop.
        It reads the light sensor value, calculates steering correction using proportional
        control, and adjusts motor speeds accordingly. The parent code is responsible
        for calling this method repeatedly in a loop.
        
        The control algorithm works by:
        1. Reading light reflection from the color sensor
        2. Calculating error as (target_light - current_light)
        3. Applying proportional gain (kp) to generate steering correction
        4. Adjusting left/right motor speeds based on correction
        
        Motor behavior:
        - Left motor (port C): Runs in reverse direction (-speed)
        - Right motor (port D): Runs in forward direction (+speed)
        - Steering correction added or subtracted from left, added or subtracted from right
        
        Returns:
            None: Executes one control iteration and returns.
        
        Raises:
            Usually no errors, but the robot might have problems if the motors or sensors stop working properly.
        
        Note:
            - Color sensor must be set to reflection mode before calling this method.
            - Parent code should call this method repeatedly in a loop for continuous line following
            - Each call performs one sensor reading and motor speed adjustment
            - Debug information is printed each iteration showing sensor readings and calculated motor speeds
        
        Example:
            # Parent code controls the loop
            line_follower = LineFollow(60, 180, 6.8)
            
            # Run for specific number of iterations
            for i in range(100):
                await line_follower.follow_line()
                await sleep_ms(100)  # Add delay between iterations
            
            # Or run indefinitely
            while True:
                await line_follower.follow_line()
                await sleep_ms(100)
        """
        # Turn On Butterfly For 2 Seconds
        #light_matrix.show_image(light_matrix.IMAGE_BUTTERFLY) # pyright: ignore[reportUndefinedVariable]
        #sleep(2)        # pyright: ignore[reportUndefinedVariable] # Perform one line following iteration
        
        light_intensity = color_sensor.reflection(port.F) # pyright: ignore[reportUndefinedVariable]
        steering_correction = self.kp * (self.target_light - light_intensity)
        
        left_speed = self.speed + steering_correction
        right_speed = self.speed - steering_correction
        
        motor.run(port.C, -int(left_speed)) # pyright: ignore[reportUndefinedVariable]
        motor.run(port.D, int(right_speed)) # pyright: ignore[reportUndefinedVariable]
        
        self.debug_print(self.iteration, self.target_light, self.speed, self.kp, light_intensity, 
                         steering_correction, left_speed, right_speed)
        
        self.iteration += 1

    def debug_print(self, iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed):
        """Debug printing utility"""
        print("Iteration: {:3d} | Target_Light: {:3d} | Speed: {:3d} | KP: {:6.2f} | Steering_Correction: {:6.2f} | Left_Speed: {:6.2f} | Right_Speed: {:6.2f}".format(
            iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed))
        

    async def stop_motors(self):
        """Stop both motors"""
        motor.stop(port.C) # pyright: ignore[reportUndefinedVariable]
        motor.stop(port.D) # pyright: ignore[reportUndefinedVariable]        `
                    },
                    {
                        id: "fn3",
                        buttonText: 'Line Follower Proportional',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    for i in range(300):
        if distance_sensor.distance(port.B) < 50 and distance_sensor.distance(port.B) != -1:
            motor_pair.stop(motor_pair.PAIR_1)
            sleep(2)
        await robot.follow_line()
        sleep_ms(100)
   `
                    },                    
                    {
                        id: "fn4",
                        buttonText: 'Line Counter (Class)',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
# This class keeps track of how many colored lines we've seen
class ColorCounter:
    """
    A class to count different colored lines detected by a color sensor.
    
    This class maintains counts for red, yellow, and blue lines and prevents
    double-counting by tracking the last color seen.
    
    Example usage:
        # Create a new counter
        counter = ColorCounter()
        
        # Look for red lines using sensor on port A
        counter.look_for_color(9, 'red', port.A)  # 9 is RED_COLOR
        
        # Check how many red lines we've found
        print(f"Found {counter.red_count} red lines")
        
        # Get all counts
        total_lines = counter.red_count + counter.yellow_count + counter.blue_count
    """
    
    def __init__(self):
        """
        Initialize a new ColorCounter with all counts set to zero.
        
        Example:
            counter = ColorCounter()
            # counter.red_count is now 0
            # counter.yellow_count is now 0  
            # counter.blue_count is now 0
        """
        # Start with zero counts for each color
        self.red_count = 0
        self.yellow_count = 0
        self.blue_count = 0
        self.last_color_seen = None  # Remember what color we just saw

    def look_for_color(self, target_color, color_name, sensor_port):
        """
        Check if we see a specific color and count it.
        
        Args:
            target_color (int): The color number to look for (e.g., 9 for red)
            color_name (str): Name of the color ('red', 'yellow', or 'blue')
            sensor_port: The port where the color sensor is connected
            
        Example:
            # Look for red lines using the color sensor on port A
            counter.look_for_color(RED_COLOR, 'red', port.A)
            
            # After calling this, if a red line was detected:
            # counter.red_count will be incremented by 1
            # The hub's power button will show the current color
            # Counts will be printed to console
        """
        # What color is the sensor seeing right now?
        current_color = color_sensor.color(sensor_port)
        
        # Show the current color on the hub's power button
        light.color(light.POWER, current_color)
        
        # Only count if we see the target color AND it's different from last time
        # (This prevents counting the same line multiple times)
        if current_color == target_color and self.last_color_seen != target_color:
            # Add 1 to the count for this color
            if color_name == 'red':
                self.red_count += 1
            elif color_name == 'yellow':
                self.yellow_count += 1
            elif color_name == 'blue':
                self.blue_count += 1

            # Show our current counts
            print(f"Red lines: {self.red_count}, Yellow lines: {self.yellow_count}, Blue lines: {self.blue_count}")
        
        # Remember this color for next time
        self.last_color_seen = current_color
   `
                    },
                    {
                        id: "fn2",
                        buttonText: 'Line Counter is_Color Blue',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `

# Variables to count how many times we see each color
red_count = 0
yellow_count = 0
blue_count = 0

# Color codes - these numbers represent different colors to the robot
blue = 3
yellow = 7
red = 9

# Remember the last color we saw so we don't count the same color twice in a row
last_color = None

# This is like a stop sign for our program - when it's True, everything stops
should_stop = False

# This function watches for blue colors
# The "async" means it can work at the same time as other functions
async def check_blue():
    # Use "global" to access variables from outside this function
    global blue_count, last_color, should_stop

    while not should_stop:
        # Ask the color sensor what color it sees right now
        current_color = color_sensor.color(port.F)

        if current_color == blue and last_color != blue:
            light.color(light.POWER, current_color)
            last_color = blue
            blue_count += 1

        await runloop.sleep_ms(100)

    `
                    },

                ]
            },   // Functions
            
        };

        document.addEventListener('DOMContentLoaded', () => {
            refreshSnippets(1);
            fetchGitHubRelease();
        });
    </script>
    <script src="./utils.js"></script>
</body>
</html>