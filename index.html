<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Paste with caret-relative indentation</title>
    <style>
        textarea {
            width: 90%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <!-- Left column with emoji buttons -->
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button onclick="refreshSnippets(1)">ðŸ”µ</button>
                <div class="emoji-label">Motors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(2)">ðŸ”´</button>
                <div class="emoji-label">Movement</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(3)">ðŸŸ£</button>
                <div class="emoji-label">Light</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(4)">ðŸŸ¡</button>
                <div class="emoji-label">Events</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(5)">ðŸŸ¡</button>
                <div class="emoji-label">Control</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(6)">ðŸ”µ</button>
                <div class="emoji-label">Sensors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(7)">ðŸŸ¢</button>
                <div class="emoji-label">Operators</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(8)">ðŸ”´</button>
                <div class="emoji-label">Functions</div>
            </div>
        </div>
    </div>

    <div style="margin: 8px 0; padding: 6px; border: 1px solid #ddd; max-width: 900px;">
        <strong>Clipboard align:</strong>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="raw" checked> Raw (no indent)
        </label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="caret"> Page caret</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="spike"> Spike caret (from other
            tab)</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="column"> Column
            <input id="clip-column" type="number" min="0" value="0" style="width:4em; margin-left:4px;">
        </label>
        <button id="open-spike" style="margin-left:12px;">Open SPIKE Editor</button>
        <span id="spike-caret-indicator" style="margin-left:12px; color:#0a7; font-family:monospace;"></span>
        <span style="margin-left:12px; color:#666;">This only affects the clipboard. In-page insert still aligns
            subsequent lines to the caret in the test area.</span>
    </div>

    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>

    <textarea id="t"></textarea>

    <script>
        // Track the last-focused editable element (textarea/input/contentEditable)
        window.__lastEditable = null;
        document.addEventListener('focusin', (ev) => {
            try {
                const t = ev.target;
                if (!t) return;
                const tag = (t.tagName || '').toLowerCase();
                if (tag === 'textarea' || (tag === 'input' && /text|search|url|email|password/.test(t.type)) || t.isContentEditable) {
                    window.__lastEditable = t;
                }
            } catch (e) { }
        });

        const snippetData = {
            1: {
                snippets: [
                    {
                        id: "m1",
                        buttonText: 'Run shortest distance to absolute 0',
                        emoji: 'ðŸ§¿',
                        color: '#0000FF',
                        textPython: `
# Run shortest distance to absolute 0
await motor.run_to_absolute_position(port.E, 0, 200, direction=motor.SHORTEST_PATH)`
                    }
                ]
            },  // motors

            2: {
                snippets: [
                    {
                        id: "move1",
                        buttonText: 'move forward for 10cm',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# move forward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10*21, 0)`
                    },
                    {
                        id: "move2",
                        buttonText: 'move backward for 10cm',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# move backward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -10*21, 0)`
                    },
                    {
                        id: "move3",
                        buttonText: 'start moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# start moving
motor_pair.move(motor_pair.PAIR_1, 0)`
                    },
                    {
                        id: "move4",
                        buttonText: 'turn in place right 90',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# turn in place right 90 (180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 180, 100)`
                    },
                    {
                        id: "move5",
                        buttonText: 'turn in place left 90',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# turn in place left 90 (-180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -180, 100)`
                    },
                    {
                        id: "move6",
                        buttonText: 'pivot turn right 90 degrees',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn right 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 50)`
                    },
                    {
                        id: "move7",
                        buttonText: 'pivot turn left 90 degrees',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn left 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -360, 50)`
                    },
                    {
                        id: "move8",
                        buttonText: 'stop moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# stop moving
motor_pair.stop(motor_pair.PAIR_1)`
                    },
                    {
                        id: "move9",
                        buttonText: 'set movement speed to 50%',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# set movement speed to 50%
movement_speed = int(0.5 * 1100)`
                    },
                    {
                        id: "move10",
                        buttonText: 'set movement motors to C+D',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# set movement motors to C+D
motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)`
                    }
                ]
            },  // Movement

            3: {
                snippets: [
                    {
                        id: "light1",
                        buttonText: 'Turn On Smiley Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Turn On Smiley Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_SMILE)
sleep(2)`
                    },
                    {
                        id: "light2",
                        buttonText: 'Blinking Eyes',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Blinking Eyes on the light matrix
blinking_eyes()`
                    },
                    {
                        id: "light3",
                        buttonText: 'Turn On Angry Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Turn On Angry Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_ANGRY)
sleep(2)`
                    }
                ]
            },  // light

            5: {
                snippets: [
                    {
                        id: "ctrl1",
                        buttonText: 'Wait for 1 second',
                        emoji: 'ðŸ§¿',
                        color: '#E0C83C',
                        textPython: `
# Wait for 1 second
sleep(1)`
                    },
                    {
                        id: "ctrl2",
                        buttonText: 'Wait For Force Sensor Pressed',
                        emoji: 'ðŸ§¿',
                        color: '#E0C83C',
                        textPython: `
# Wait For Force Sensor Pressed
while force_sensor.force(port.A) < 1: pass`
                    }
                ]
            },  // Control

            6: {
                snippets: [
                    {
                        id: "sens1",
                        buttonText: 'Distance Check (example)',
                        emoji: 'ðŸ§¿',
                        color: '#34CCF1',
                        textPython: `
# Example sensor check
if distance_sensor.get_distance() < 10:
print('close')`
                    }
                ]
            },  // Sensor

            7: {
                snippets: [
                    {
                        id: "op1",
                        buttonText: 'Operator Example',
                        emoji: 'ðŸ§¿',
                        color: '#6AA84F',
                        textPython: `
# Operator example
result = a + b  `
                    }
                ]
            },  // Operators

            8: {
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Getting Started',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `# ChallengeName
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light_matrix, port, sound
from time import sleep, sleep_ms
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

runloop.run(main())
sys.exit()    
`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Distance Sensor',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `
# Move forward until object within 10cm
if distance_sensor.distance(port.B) > 100 or distance_sensor.distance(port.B) == -1: pass`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Blinking Eyes (function)',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `
def blinking_eyes():
    # Show a blinking eyes animation on the Light Matrix
    for i in range(3):
        light_matrix.show_image(light_matrix.IMAGE_HAPPY)
        sleep_ms(1000)
        
        light_matrix.show_image(light_matrix.IMAGE_SMILE)
        sleep_ms(200)

    light_matrix.show_image(light_matrix.IMAGE_HAPPY)
    sleep_ms(2000)
    `
                    }
                ]
            }   // Functions
        };

        // Central setter for SPIKE caret column so we don't lose it
        function setSpikeCaretCol(col, source) {
            const n = Math.max(0, (col | 0));
            window.__spikeCaretCol = n;
            // Update UI indicator and auto-select Spike mode so caretSpaces is used
            try {
                const ind = document.getElementById('spike-caret-indicator');
                if (ind) ind.textContent = `Spike caret: ${n}`;
                const radios = document.querySelectorAll('input[name="clipmode"]');
                radios.forEach(r => { if (r.value === 'spike') r.checked = true; });
            } catch (_) { }
            try {
                const ts = new Date().toLocaleTimeString();
                console.log(`[SPIKE caret] Set to ${n} from ${source} at ${ts}`);
            } catch (_) {
                console.log('[SPIKE caret] Set to', n, 'from', source);
            }
        }

        // Get the caret column (0-based) from the last-focused editable control (textarea/input/contentEditable)
        function getCaretColumnFromActiveEditable() {
            const el = window.__lastEditable || document.getElementById('t');
            if (!el) return 0;

            // Textarea or text-like input
            const isTextInput = el && (el.tagName || '').toLowerCase() === 'textarea' || ((el.tagName || '').toLowerCase() === 'input' && /text|search|url|email|password/.test(el.type));
            if (isTextInput) {
                const v = el.value || '';
                const selStart = typeof el.selectionStart === 'number' ? el.selectionStart : 0;
                const lineStart = v.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                return Math.max(0, selStart - lineStart);
            }

            // contentEditable (best-effort fallback): return 0 if we can't compute
            try {
                const sel = window.getSelection();
                if (sel && sel.rangeCount) {
                    const range = sel.getRangeAt(0);
                    // naive: count chars since last newline in the textContent of the current block
                    const container = range.startContainer;
                    const textBefore = container.textContent ? container.textContent.slice(0, range.startOffset) : '';
                    const lastNl = textBefore.lastIndexOf('\n');
                    return lastNl >= 0 ? (textBefore.length - 1 - lastNl) : textBefore.length;
                }
            } catch (_) { }
            return 0;
        }

        // Build clipboard text so lines 2..n are padded to align under the caret column; first line starts at caret
        function buildClipboardTextSubsequentOnly(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (!lines.length) return '';
            const out = new Array(lines.length);
            // First line: no padding so it starts at caret
            out[0] = lines[0] || '';
            for (let i = 1; i < lines.length; i++) {
                out[i] = pad + lines[i];
            }
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Build clipboard text so ALL lines are shifted to start at the caret column (pads every line)
        function buildClipboardTextAllLinesCaretShift(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const out = lines.map(line => pad + line);
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Ensure this tab is focused before attempting clipboard operations (required by browsers)
        async function ensureThisTabFocused(timeoutMs = 300) {
            if (document.hasFocus && document.hasFocus()) return true;
            try { window.focus(); } catch (_) { }
            // Wait briefly for a focus event or timeout
            return await new Promise((resolve) => {
                let settled = false;
                const done = (val) => { if (!settled) { settled = true; resolve(val); } };
                const onFocus = () => { window.removeEventListener('focus', onFocus); done(true); };
                window.addEventListener('focus', onFocus, { once: true });
                setTimeout(() => {
                    window.removeEventListener('focus', onFocus);
                    done(document.hasFocus ? document.hasFocus() : true);
                }, timeoutMs);
            });
        }

        // Keep a handle to the SPIKE window if opened, so we can focus it later
        function getSpikeWindow() {
            const w = window.__spikeWin;
            return w && !w.closed ? w : null;
        }
        function tryFocusSpikeWindow() {
            let w = getSpikeWindow();
            if (!w) {
                // Try to attach to an existing named window if user opened SPIKE manually
                try {
                    w = window.open('', 'spike-editor-tab');
                    if (w) window.__spikeWin = w;
                } catch (_) { /* noop */ }
            }
            if (!w) return false;
            try { w.focus(); return true; } catch (_) { return false; }
        }

        // Copy plain text to clipboard with fallback
        async function copyPlainText(text) {
            try {
                // The async Clipboard API generally requires the calling document to be focused
                await ensureThisTabFocused(300);
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (err) {
                console.log('[Clipboard] navigator.clipboard.writeText error:', err);
                // fall through to legacy fallback below
            }
            try {
                const tmp = document.createElement('textarea');
                tmp.value = text;
                tmp.setAttribute('readonly', '');
                tmp.style.position = 'fixed';
                tmp.style.opacity = '0';
                tmp.style.pointerEvents = 'none';
                document.body.appendChild(tmp);
                tmp.focus();
                tmp.select();
                const ok = document.execCommand('copy');
                document.body.removeChild(tmp);
                return ok;
            } catch (_) {
                return false;
            }
        }

        // Determine clipboard alignment mode from the UI controls
        function getClipboardAlignMode() {
            const radios = document.querySelectorAll('input[name="clipmode"]');
            let mode = 'raw';
            radios.forEach(r => { if (r.checked) mode = r.value; });
            if (mode === 'column') {
                const v = parseInt((document.getElementById('clip-column') || {}).value, 10);
                return { mode, column: isNaN(v) ? 0 : Math.max(0, v) };
            }
            return { mode };
        }

        // Build clipboard text based on the selected mode
        function buildClipboardFromMode(text) {
            const { mode, column } = getClipboardAlignMode();
            if (mode === 'raw') {
                // No indentation adjustments; normalize to CRLF for Windows editors
                return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
            }
            if (mode === 'caret') {
                const caretCol = getCaretColumnFromActiveEditable();
                return buildClipboardTextAllLinesCaretShift(text, caretCol);
            }
            if (mode === 'spike') {
                const spikeCol = (typeof window.__spikeCaretCol === 'number') ? window.__spikeCaretCol : null;
                if (spikeCol === null) {
                    console.warn('[SPIKE caret] Spike mode selected but no caret received yet; defaulting to 0.');
                } else {
                    console.log('[SPIKE caret] Using caretSpaces =', spikeCol);
                }
                return buildClipboardTextAllLinesCaretShift(text, spikeCol ?? 0);
            }
            if (mode === 'column') {
                return buildClipboardTextAllLinesCaretShift(text, column || 0);
            }
            return (text || '');
        }

        // Main function split for readability
        // Main function split for readability
        async function copySnippetWithLineInsert(preId) {
            const el = document.getElementById(preId);
            if (!el) {
                console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
                alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
                return;
            }

            const raw = el.textContent || '';

            // Debug: show current mode and spike caret prior to building clipboard
            const modeSnapshot = getClipboardAlignMode();
            console.log('[Clipboard] mode =', modeSnapshot, ' __spikeCaretCol =', window.__spikeCaretCol);

            // Build clipboard according to selected align mode
            const prepared = buildClipboardFromMode(raw);
            const copied = await copyPlainText(prepared);
            if (!copied) console.warn('Clipboard copy may have failed.');

            // In-page insert: still insert raw so first line is at caret and others align
            processAndInsertText(raw);

            // After copying, bring the SPIKE window to the front for quick paste
            const spikeFocused = tryFocusSpikeWindow();
            const focusHint = spikeFocused ? '' : '\n\nTip: Couldn\'t bring SPIKE to frontâ€”Alt+Tab to it and paste.';

            alert('Clipboard ready. Move to your target editor and paste.' + focusHint);
        }
        function refreshSnippets(buttonId) {
            const column = document.getElementById('snippet-column');
            column.innerHTML = '';

            const data = snippetData[buttonId];
            if (!data) return;

            data.snippets.forEach((snippet, index) => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet movement';
                const preId = `snippet-${buttonId}-${index}`;
                const pre = document.createElement('pre');
                pre.id = preId;
                pre.contentEditable = true;
                pre.style.display = 'none';
                const parts = [];
                parts.push(snippet.textPython);
                pre.textContent = parts.join('\n') + '\n';

                snippetDiv.appendChild(pre);

                const button = document.createElement('button');
                // emoji slightly larger via CSS class
                button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
                button.style.backgroundColor = snippet.color;
                button.style.color = '#ffffff';
                button.title = snippet.buttonText; // keep accessible label

                console.log('removed the message to please insert caret first');

                // Click inserts into textarea and prepares clipboard with proper indentation for external paste
                button.addEventListener('click', () => copySnippetWithLineInsert(preId));

                snippetDiv.appendChild(button);
                column.appendChild(snippetDiv);
            });
        }

        // Insert multiline text with caret-relative indentation into #t on paste; expose processAndInsertText.
        (function () {
            const ta = document.getElementById('t');

            function processAndInsertText(inputText) {
                if (!inputText) return; // nothing to do

                const value = ta.value;
                const selStart = ta.selectionStart;
                const selEnd = ta.selectionEnd;

                // find start index of the current line where the caret is (or selection start)
                const lineStart = value.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                const caretColumn = selStart - lineStart; // number of characters from line start to caret

                // build the padding string (spaces). If you prefer tabs, change this.
                const pad = ' '.repeat(caretColumn);

                // Normalize newlines in inputText (handles CRLF)
                const pastedLines = inputText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

                // If the user is replacing a selection, the first pasted line should be inserted at selStart,
                // so we do not prefix the first line. Only subsequent lines get the pad prefixed.
                for (let i = 1; i < pastedLines.length; i++) {
                    pastedLines[i] = pad + pastedLines[i];
                }

                const toInsert = pastedLines.join('\n');

                // Replace selection with our processed text
                const newValue = value.slice(0, selStart) + toInsert + value.slice(selEnd);
                ta.value = newValue;

                // compute new caret position: place caret just after the inserted content
                const newCaretPos = selStart + toInsert.length;
                ta.setSelectionRange(newCaretPos, newCaretPos);
                // optional: trigger input event if other code listens for it
                ta.dispatchEvent(new Event('input', { bubbles: true }));
            }

            ta.addEventListener('paste', function (ev) {
                // get plain text from clipboard
                const clipboardText = (ev.clipboardData || window.clipboardData).getData('text');
                ev.preventDefault(); // we'll insert our processed text
                processAndInsertText(clipboardText);
            });

            // insert multiline text into the textarea at caret position with proper indentation
            window.processAndInsertText = processAndInsertText;
        })();

        document.addEventListener('DOMContentLoaded', () => refreshSnippets(1));

        // SPIKE editor caret column support
        // BroadcastChannel 'spike-caret-column' is used to receive caret column updates from other tabs or windows
        // specifically for SPIKE editor integration. This channel is dedicated to transmitting only the caret column
        // as a number, whereas the 'spike-caret' channel may transmit more complex messages (objects with type and column).
        (function () {
            const bc = new BroadcastChannel('spike-caret-column');
            bc.onmessage = (ev) => {
                if (typeof ev.data === 'number') {
                    setSpikeCaretCol(ev.data, 'BroadcastChannel: spike-caret-column');
                }
            };
        })();

        // Shared channel to receive caret column from the SPIKE editor tab (same-origin only)
        const spikeChannel = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('spike-caret') : null;
        window.__spikeCaretCol = null; // initialize once
        if (spikeChannel) {
            spikeChannel.onmessage = (ev) => {
                try {
                    const data = ev.data;
                    if (data && data.type === 'caret' && typeof data.column === 'number') {
                        setSpikeCaretCol(data.column, 'BroadcastChannel: spike-caret');
                    }
                } catch (err) {
                    console.log('[SPIKE caret] BroadcastChannel onmessage error:', err);
                    alert('Error processing message from SPIKE editor. See console for details.');
                    // continue without interrupting fallback mechanisms
                }
            };
        }

        // Cross-tab caret receiver via postMessage from SPIKE tab
        // Do NOT reset __spikeCaretCol here; we preserve last-known value
        // THIS IS WHERE WE LOG THE INCOMING MESSAGES FROM SPIKE CTRL ALT R
        window.addEventListener('message', (ev) => {
            try {
                // Only trust known SPIKE origins
                const ALLOWED_SPIKE_ORIGINS = new Set([
                    'https://spike.legoeducation.com'
                ]);
                if (!ALLOWED_SPIKE_ORIGINS.has(ev.origin)) {
                    // Uncomment for troubleshooting:
                    // console.debug('[SPIKE caret] Ignoring message from origin:', ev.origin, 'data =', ev.data);
                    return;
                }

                // Accept either a structured object { type:'spike-caret', column:number }
                // or a plain number (column) for simple integrations.
                const d = ev.data;
                let col = null;
                if (d && typeof d === 'object') {
                    if (d.type === 'spike-caret' && typeof d.column === 'number' && isFinite(d.column)) {
                        col = d.column;
                    }
                } else if (typeof d === 'number' && isFinite(d)) {
                    col = d;
                }

                if (col !== null) {
                    console.log('[SPIKE caret] postMessage from', ev.origin, 'column =', col);
                    setSpikeCaretCol(col, `postMessage: ${ev.origin}`);
                } else {
                    // Uncomment for troubleshooting unexpected payloads:
                    // console.debug('[SPIKE caret] Unrecognized message payload from', ev.origin, d);
                }
            } catch (err) {
                console.log('[SPIKE caret] postMessage handler error:', err);
                // Avoid alert spam; keep UX smooth.
            }
        });

        // Helper to open SPIKE page with opener preserved (no noopener)
        document.getElementById('open-spike').addEventListener('click', () => {
            const url = 'https://spike.legoeducation.com/prime/project';
            // Open without noopener so window.opener is available for postMessage
            const w = window.open(url, 'spike-editor-tab');
            // Save handle for later focusing
            window.__spikeWin = w || window.__spikeWin;
            if (!w) {
                alert('Popup blocked. Please allow pop-ups for this site, then try again.');
            }
        });
    </script>
</body>

</html>