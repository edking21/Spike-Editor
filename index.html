<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Spike</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 2px;
            background-color: #ffffff;
            color: #000000;
            margin: 0;
        }

        .left-column {
            position: fixed;
            top: 0;
            left: 0;
            width: 80px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background-color: #f5f5f5;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
        }

        .emoji-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding-top: 12px;
            height: 100%;
            overflow-y: auto;
            width: 100%;
        }

        .emoji-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .emoji-container button {
            font-size: 32px;
            cursor: pointer;
            border: none;
            background: none;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .emoji-container button:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-label {
            margin-top: 1px;
            font-size: 12px;
            color: black;
            text-align: center;
            width: 70px;
            word-wrap: break-word;
        }

        .snippet-column {
            margin-left: 80px;
            padding: 0px 12px 12px 12px;
        }

        .snippet {
            border: none;
            border-radius: 8px;
            padding: 6px;
            margin: 8px 0;
            background-color: transparent;
            width: 100%;
            box-sizing: border-box;
        }

        .snippet button {
            cursor: pointer;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            color: #ffffff;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.12s ease, filter 0.12s ease;
        }

        .snippet button:hover {
            transform: scale(1.04);
            filter: brightness(110%);
        }

        .snippet .emoji {
            font-size: 1.3em;
            line-height: 1;
        }

        .snippet .label {
            font-size: 1em;
        }

        .release-info {
            text-align: center;
            margin-top: 400px;
            padding: 20px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
        }

        .emoji-container .color-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
            font-size: 0; /* Remove any text content */
        }

        .emoji-container .color-circle:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-container .blue-circle { background-color: #0066FF !important; }
        .emoji-container .light-blue-circle { background-color: #87CEEB !important; }
        .emoji-container .red-circle { background-color: #CC0000 !important; }
        .emoji-container .pink-circle { background-color: #FF69B4 !important; }
        .emoji-container .purple-circle { background-color: #8A2BE2 !important; }
        .emoji-container .yellow-circle { background-color: #FFD700 !important; }
        .emoji-container .dark-yellow-circle { background-color: #DAA520 !important; }
        .emoji-container .green-circle { background-color: #32CD32 !important; }
    </style>
</head>
<body>
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button class="color-circle blue-circle" onclick="refreshSnippets(1)"></button>
                <div class="emoji-label">Motors</div>
            </div>
            <div class="emoji-container"><button class="color-circle pink-circle" onclick="refreshSnippets(2)"></button>
                <div class="emoji-label">Movement</div>
            </div>
            <div class="emoji-container"><button class="color-circle purple-circle" onclick="refreshSnippets(3)"></button>
                <div class="emoji-label">Light</div>
            </div>
            <div class="emoji-container"><button class="color-circle yellow-circle" onclick="refreshSnippets(4)"></button>
                <div class="emoji-label">Events</div>
            </div>
            <div class="emoji-container"><button class="color-circle dark-yellow-circle" onclick="refreshSnippets(5)"></button>
                <div class="emoji-label">Control</div>
            </div>
            <div class="emoji-container"><button class="color-circle light-blue-circle" onclick="refreshSnippets(6)"></button>
                <div class="emoji-label">Sensors</div>
            </div>
            <div class="emoji-container"><button class="color-circle green-circle" onclick="refreshSnippets(7)"></button>
                <div class="emoji-label">Operators</div>
            </div>
            <div class="emoji-container"><button class="color-circle red-circle" onclick="refreshSnippets(8)"></button>
                <div class="emoji-label">Functions</div>
            </div>
        </div>
    </div>
    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>
    <div class="snippet-column">
        <div class="release-info" id="release-info">
            Â© 2024 Spike Editor - Loading release info...
        </div>
    </div>
    <script>
        const snippetData = {
            1: {  // Motors
                snippets: [
                    {
                        id: "m1",
                        buttonText: 'Run shortest distance to absolute 0',
                        emoji: 'ðŸ§¿',
                        color: '#0066FF',
                        textPython: `
    # Run shortest distance to absolute 0
    await motor.run_to_absolute_position(port.E, 0, 200, direction=motor.SHORTEST_PATH)`
                    }
                ]
            },  // motors

            2: {  // Movement
                snippets: [
                    {
                        id: "move1",
                        buttonText: 'move forward for 20cm',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # move forward for 10cm
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10*21, 0)`
                    },
                    {
                        id: "move3",
                        buttonText: 'start moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # start moving
    motor_pair.move(motor_pair.PAIR_1, 0)`
                    },
                    {
                        id: "move4",
                        buttonText: 'move right 30 for 10 rotations',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # move right 30 for 10 rotations 
    degrees = 360 * 10 # 10 rotations
    steering = 30 # positive values turn right, negative values turn left
    await motor_pair.move_for_degrees(motor_pair.PAIR_1, degrees, steering )`
                    },
                    {
                        id: "move6",
                        buttonText: 'start moving right 30',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # start moving right 30 
    steering = 30 # positive values turn right, negative values turn left
    speed = 220 # 20% of max speed (1100)
    motor_pair.move(motor_pair.PAIR_1, steering, velocity=speed)
    sleep(2)`
                    },
                    {
                        id: "move8",
                        buttonText: 'stop moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # stop moving
    motor_pair.stop(motor_pair.PAIR_1)`
                    },
                    {
                        id: "move9",
                        buttonText: 'set movement speed to 50%',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # set movement speed to 50%
    movement_speed = int(0.5 * 1100)`
                    },
                    {
                        id: "move10",
                        buttonText: 'set movement motors to C+D',
                        emoji: 'ðŸ§¿',
                        color: '#FF69B4',
                        textPython: `
    # set movement motors to C+D
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)`
                    }
                ]
            },  // Movement

            3: {  // Light
                snippets: [
                    {
                        id: "light1",
                        buttonText: 'Turn On Smiley Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    # Turn On Smiley Face For 2 Seconds
    light_matrix.show_image(light_matrix.IMAGE_SMILE)
    sleep(2)`
                    },
                    {
                        id: "light2",
                        buttonText: 'Blinking Eyes',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    # Blinking Eyes on the light matrix
    blinking_eyes()`
                    },
                    {
                        id: "light3",
                        buttonText: 'Turn On Angry Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#8A2BE2',
                        textPython: `
    # Turn On Angry Face For 2 Seconds
    light_matrix.show_image(light_matrix.IMAGE_ANGRY)
    sleep(2)`
                    }
                ]
            },  // light

            4: {  // Events
                snippets: [
                    {
                        id: "ev1",
                        buttonText: 'Wait for 1 second',
                        emoji: 'ðŸ§¿',
                        color: '#FFD700',
                        textPython: `
    # Wait for 1 second
    sleep(1)`
                    }
                ]
            },  // Control
           
            5: {  // Control
                snippets: [
                    {
                        id: "ctrl1",
                        buttonText: 'Wait for 1 second',
                        emoji: 'ðŸ§¿',
                        color: '#DAA520',
                        textPython: `
    # Wait for 1 second
    sleep(1)`
                    },
                    {
                        id: "ctrl2",
                        buttonText: 'Repeat until <test sensor here>',
                        emoji: 'ðŸ§¿',
                        color: '#DAA520',
                        textPython: `
    # Repeat until 
    while <add sensor boolean here> `
                    },
                    {
                        id: "ctrl3",
                        buttonText: 'Wait until <test sensor here>',
                        emoji: 'ðŸ§¿',
                        color: '#DAA520',
                        textPython: `
    # Wait until 
    while <add sensor boolean here> `
                    },
                ]
            },  // Control

            6: {  // Sensors
                snippets: [
                        {
                        id: "fn2",
                        buttonText: 'is closer than 10cm',
                        emoji: 'ðŸ§¿',
                        color: '#87CEEB',
                        textPython: 
    `distance_sensor.distance(port.B) > 100 or distance_sensor.distance(port.B) == -1:`
                    },
                        {
                        id: "fn2",
                        buttonText: 'is color red',
                        emoji: 'ðŸ§¿',
                        color: '#87CEEB',
                        textPython: 
    `color_sensor.color(port.A) != color.RED:`
                    },
                ]
            },  // Sensor

            7: {  // Operators  
                snippets: [
                    {
                        id: "op1",
                        buttonText: 'Operator Example',
                        emoji: 'ðŸ§¿',
                        color: '#32CD32',
                        textPython: `
    # Operator example
    result = a + b  `
                    }
                ]
            },  // Operators

            8: {  // Functions
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Getting Started',
                        emoji: 'ðŸ§¿',
                        color: '#CC0000',
                        textPython: `# <challenge name here>
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light_matrix, port, sound
from time import sleep, sleep_ms
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

runloop.run(main())
sys.exit()` 
                    },
                    {
                        id: "fn2",
                        buttonText: 'Blinking Eyes (function)',
                        emoji: 'ðŸ§¿',
                        color: '#CC0000',
                        textPython: `
def blinking_eyes():
    # Show a blinking eyes animation on the Light Matrix
    for i in range(3):
        light_matrix.show_image(light_matrix.IMAGE_HAPPY)
        sleep_ms(1000)
        
        light_matrix.show_image(light_matrix.IMAGE_SMILE)
        sleep_ms(200)

    light_matrix.show_image(light_matrix.IMAGE_HAPPY)
    sleep_ms(2000)
    `
                    },
                    {
                        id: "fn3",
                        buttonText: 'Line Follow (Class)',
                        emoji: 'ðŸ§¿',
                        color: '#CC0000',
                        textPython: `
    # create robot object from LineFollow class    
    robot = LineFollow(target_light=60, speed=180, kp=6.8)

    # Follow line for 30 iterations then stop
    await robot.follow_line(iterations=30)





























class LineFollow:
    """A robot that can follow a line.
    
    This robot uses a light sensor to see the edge between the dark and light and automatically steers
    the wheels to stay over the edge by adjusting the motor speeds.
     
    Attributes:
        target_light (int): The desired light intensity the robot tries to stay on.
            Defaults to 60.
        speed (int): How fast the robot moves.
            Defaults to 180.
        kp (float): Proportional gain for steering correction.
            Defaults to 6.8.

    Args:
        iterations (str): Number of iterations to run the line following loop. If None, runs indefinitely.
            Defaults to None.
            
    Example:
        Basic usage example:

            line_follower = LineFollow(target_light=60, speed=180, kp=6.8)

            await line_follower.follow_line(iterations=30)  # Run for 30 iterations then stop

    Note:
        - Target_light is computed from half the difference between the value returned from the sensor when positioning over the light then over the dark. 
        - Higher speeds are mostly for competition runs. 
        - kp is the gain in a PID controller.
    """

    def __init__(self, target_light=60, speed=180, kp=6.8):
        self.target_light = target_light
        self.speed = speed
        self.kp = kp
    
    async def follow_line(self, iterations=None):
        """Execute line following behavior using proportional control algorithm.
        
        This method implements the main control loop for line following. It continuously
        reads light sensor values, calculates steering corrections using proportional
        control, and adjusts motor speeds to keep the color sensor centered on the edge between 
        light and dark.
        
        The control algorithm works by:
        1. Reading light reflection from the color sensor
        2. Calculating error as (target_light - current_light)
        3. Applying proportional gain (kp) to generate steering correction
        4. Adjusting left/right motor speeds based on correction
        5. Repeating until stopped or iteration limit reached
        
        Motor behavior:
        - Left motor (port C): Runs in reverse direction (-speed)
        - Right motor (port D): Runs in forward direction (+speed)
        - Steering correction added or subtracted from left, added or subtracted from right
        
        Args:
            iterations (str): Number of iterations to run the line following loop. If None, runs indefinitely.
                Defaults to None.

        Returns:
            None: This is an async method that runs until completion or interruption.
        
        Raises:
            Usually no errors, but the robot might have problems if the motors or sensors stop working properly.
        
        Note:
            - Color sensor must be set to relection mode before calling this method.
            - If no iterations runs indefinitely until manually stopped. 
            - Each iteration includes one sensor reading and motor speed adjustment.
            - Method includes 100ms delay between iterations for stable control
            - Debug information is printed each iteration showing sensor readings and calculated motor speeds
            - Motors are automatically stopped when method completes
        
        Example:
            # Run indefinitely

            await line_follower.follow_line()
            
            # Run for 50 iterations then stop

            await line_follower.follow_line(iterations=50)
        """
        iteration = 0


        while True:
            # Perform line following iteration
            light_intensity = color_sensor.reflection(port.F) # pyright: ignore[reportUndefinedVariable]
            steering_correction = self.kp * (self.target_light - light_intensity)
            
            left_speed = self.speed + steering_correction
            right_speed = self.speed - steering_correction
            
            motor.run(port.C, -int(left_speed)) # pyright: ignore[reportUndefinedVariable]
            motor.run(port.D, int(right_speed)) # pyright: ignore[reportUndefinedVariable]
            
            self.debug_print(iteration, self.target_light, self.speed, self.kp,  light_intensity, steering_correction, left_speed, right_speed)
            sleep_ms(100) # pyright: ignore[reportUndefinedVariable]
            
            iteration += 1
            
            # Break if we've reached the specified number of iterations
            if iterations is not None and iteration >= iterations:
                break
        
        # Stop motors when done
        await self.stop_motors()


    def debug_print(self, iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed):
        """Debug printing utility"""
        print("Iteration: {:3d} | Target_Light: {:3d} | Speed: {:3d} | KP: {:6.2f} | Steering_Correction: {:6.2f} | Left_Speed: {:6.2f} | Right_Speed: {:6.2f}".format(
            iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed))


    async def stop_motors(self):
        """Stop both motors"""
        motor.stop(port.C) # pyright: ignore[reportUndefinedVariable]
        motor.stop(port.D) # pyright: ignore[reportUndefinedVariable]    
        `
                    }
                ]
            }   // Functions
        };

        function refreshSnippets(buttonId) {
            const column = document.getElementById('snippet-column');
            column.innerHTML = '';

            const data = snippetData[buttonId];
            if (!data) return;

            data.snippets.forEach((snippet, index) => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet movement';

                const preId = `snippet-${buttonId}-${index}`;
                const pre = document.createElement('pre');
                pre.id = preId;
                pre.contentEditable = true;
                pre.style.display = 'none';

                // build the copy text: include function definition (if any), comment, then python body
                const parts = [];
                parts.push(snippet.textPython);
                pre.textContent = parts.join('\n') + '\n';

                //console.log(`BUILDING PRE HERE AS: ${pre.textContent}`);

                snippetDiv.appendChild(pre);

                const button = document.createElement('button');
                // emoji slightly larger via CSS class
                button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
                button.style.backgroundColor = snippet.color;
                button.style.color = (buttonId === 4 || buttonId === 5 || buttonId === 6) ? '#000000' : '#ffffff';
                button.title = snippet.buttonText; // keep accessible label

                button.addEventListener('click', () => copySnippetWithLineInsert(preId));

                snippetDiv.appendChild(button);
                column.appendChild(snippetDiv);
            });
        }

        function copySnippetWithLineInsert(preId) {
            const el = document.getElementById(preId);
            if (!el) {
                console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
                alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
                return;
            }

            const text = el.textContent || '';

            // do not add additional indentation here; keep text as authored
            const textToCopy = text;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).catch(() => fallbackCopy(textToCopy));
            } else {
                fallbackCopy(textToCopy);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try { document.execCommand('copy'); } catch (e) { console.error('fallback copy failed', e); }
            document.body.removeChild(textarea);
        }

        async function fetchGitHubRelease() {
        /**
         * Fetches the latest release information from the GitHub repository and updates the UI.
         * 
         * This function makes an API call to the GitHub releases endpoint to retrieve the latest
         * release data for the Spike-Editor repository. It updates the release-info element with
         * the fetched release name or falls back to a default version if the request fails.
         * 
         * @async
         * @function fetchGitHubRelease
         * @returns {Promise<void>} A promise that resolves when the release information has been fetched and displayed
         * @throws {Error} Throws an error if the GitHub API request fails or returns a non-ok response
         * 
         * @example
         * // Call the function to update release information
         * await fetchGitHubRelease();
         * 
         * @description
         * - Makes a GET request to 'https://api.github.com/repos/edking21/Spike-Editor/releases/latest'
         * - On success: Updates the 'release-info' element with "Â© 2025 Spike Editor - Release {release.name}"
         * - On failure: Falls back to "Â© 2025 Spike Editor - Release v1.0.0" and logs a warning
         * - Requires an HTML element with id 'release-info' to exist in the DOM
         */
            try {
                const response = await fetch('https://api.github.com/repos/edking21/Spike-Editor/releases/latest');
                if (response.ok) {
                    const release = await response.json();
                    const releaseInfo = document.getElementById('release-info');
                    releaseInfo.textContent = `Â© 2025 Spike Editor - Release ${release.name}`;
                } else {
                    throw new Error('Failed to fetch release');
                }
            } catch (error) {
                console.warn('Could not fetch GitHub release:', error);
                const releaseInfo = document.getElementById('release-info');
                releaseInfo.textContent = 'Â© 2025 Spike Editor - Release v1.0.0';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            refreshSnippets(1);
            fetchGitHubRelease();
        });
    </script>
</body>

</html>