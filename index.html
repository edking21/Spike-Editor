<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Paste with caret-relative indentation</title>
    <style>
        textarea {
            width: 90%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <!-- Left column with emoji buttons -->
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button onclick="refreshSnippets(1)">üîµ</button>
                <div class="emoji-label">Motors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(2)">üî¥</button>
                <div class="emoji-label">Movement</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(3)">üü£</button>
                <div class="emoji-label">Light</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(4)">üü°</button>
                <div class="emoji-label">Events</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(5)">üü°</button>
                <div class="emoji-label">Control</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(6)">üîµ</button>
                <div class="emoji-label">Sensors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(7)">üü¢</button>
                <div class="emoji-label">Operators</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(8)">üî¥</button>
                <div class="emoji-label">Functions</div>
            </div>
        </div>
    </div>

    <div style="margin: 8px 0; padding: 6px; border: 1px solid #ddd; max-width: 900px;">
        <div id="github-release">
            <strong>Loading GitHub release info...</strong>
        </div>
        <strong>Clipboard align:</strong>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="raw" checked> Raw (no indent)
        </label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="caret"> Page caret</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="spike"> Spike caret (from other
            tab)</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="column"> Column
            <input id="clip-column" type="number" min="0" value="0" style="width:4em; margin-left:4px;">
        </label>
        <button id="open-spike" style="margin-left:12px;">Open SPIKE Editor</button>
        <span id="spike-caret-indicator" style="margin-left:12px; color:#0a7; font-family:monospace;"></span>
        <span style="margin-left:12px; color:#666;">This only affects the clipboard. In-page insert still aligns
            subsequent lines to the caret in the test area.</span>
    </div>

    <!-- TESTING BUTTONS FOR LIGHTSPEED CHROMEBOOK DEBUGGING -->
    <div style="margin: 8px 0; padding: 6px; border: 2px solid #ff6b35; background: #fff3cd; max-width: 900px;">
        <strong>üîß Lightspeed Debugging Tools:</strong><br>
        <button id="test-keys" style="margin: 4px; background: #28a745; color: white;">Test Key Detection</button>
        <button id="send-test-caret" style="margin: 4px; background: #ff6b35; color: white;">Send Test Caret (Column 4)</button>
        <button id="manual-caret-input" style="margin: 4px; background: #007bff; color: white;">Manual Caret Input</button>
        <button id="test-restrictions" style="margin: 4px; background: #6f42c1; color: white;">Test Lightspeed Restrictions</button>
        <button id="inject-spike-listener" style="margin: 4px; background: #dc3545; color: white;">Generate SPIKE Injection Code</button>
    </div>

    <!-- DEBUG CONSOLE FOR LIGHTSPEED CHROMEBOOK -->
    <div id="debug-console" style="margin: 8px 0; padding: 10px; border: 2px solid #333; background: #f8f8f8; max-width: 900px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto;">
        <strong>Debug Console (Lightspeed Compatible):</strong>
        <div id="debug-output" style="margin-top: 5px; white-space: pre-wrap;"></div>
        <button onclick="clearDebugConsole()" style="margin-top: 5px; font-size: 11px;">Clear Debug</button>
    </div>

    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>

    <textarea id="t"></textarea>

    <script>
        // DEBUG FUNCTIONS FOR LIGHTSPEED CHROMEBOOK
        function debugLog(message, data = '') {
            const timestamp = new Date().toLocaleTimeString();
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                const logLine = `[${timestamp}] ${message} ${data ? JSON.stringify(data) : ''}\n`;
                debugOutput.textContent += logLine;
                debugOutput.scrollTop = debugOutput.scrollHeight;
            }
            // Also log to console if available
            try {
                console.log(`[DEBUG] ${message}`, data);
            } catch (e) {}
        }

        function clearDebugConsole() {
            const debugOutput = document.getElementById('debug-output');
            if (debugOutput) {
                debugOutput.textContent = '';
            }
        }

        // KEY DETECTION TEST FOR LIGHTSPEED CHROMEBOOK
        let keyTestingActive = false;
        function startKeyTesting() {
            keyTestingActive = true;
            debugLog('KEY TESTING STARTED', 'Press any key combinations...');
            
            const keyHandler = (ev) => {
                if (!keyTestingActive) return;
                
                const keys = [];
                if (ev.ctrlKey) keys.push('Ctrl');
                if (ev.altKey) keys.push('Alt');
                if (ev.shiftKey) keys.push('Shift');
                if (ev.metaKey) keys.push('Meta');
                keys.push(ev.key);
                
                debugLog('Key detected', {
                    combination: keys.join('+'),
                    code: ev.code,
                    which: ev.which,
                    keyCode: ev.keyCode,
                    prevented: ev.defaultPrevented
                });
                
                // Test specific combinations
                if (ev.ctrlKey && ev.altKey && ev.key.toLowerCase() === 'r') {
                    debugLog('üéØ CTRL+ALT+R detected!', 'This combination works on this page');
                    ev.preventDefault();
                }
                if (ev.ctrlKey && ev.shiftKey && ev.key.toLowerCase() === 'r') {
                    debugLog('üéØ CTRL+SHIFT+R detected!', 'Alternative combination works');
                    ev.preventDefault();
                }
            };
            
            document.addEventListener('keydown', keyHandler);
            
            // Auto-stop after 30 seconds
            setTimeout(() => {
                keyTestingActive = false;
                document.removeEventListener('keydown', keyHandler);
                debugLog('KEY TESTING STOPPED', 'Test completed');
            }, 30000);
        }

        // TEST LIGHTSPEED RESTRICTIONS
        function testLightspeedRestrictions() {
            debugLog('üîç Testing Lightspeed restrictions', 'Starting diagnostic tests...');
            
            // Test clipboard access
            navigator.clipboard.writeText('test').then(() => {
                debugLog('‚úÖ Clipboard access', 'ALLOWED');
            }).catch(e => {
                debugLog('‚ùå Clipboard access', 'BLOCKED: ' + e.message);
            });
            
            // Test BroadcastChannel
            try {
                const bc = new BroadcastChannel('test-channel');
                debugLog('‚úÖ BroadcastChannel', 'ALLOWED');
                bc.close();
            } catch (e) {
                debugLog('‚ùå BroadcastChannel', 'BLOCKED: ' + e.message);
            }
            
            // Test postMessage
            try {
                window.postMessage('test-message', '*');
                debugLog('‚úÖ postMessage', 'ALLOWED');
            } catch (e) {
                debugLog('‚ùå postMessage', 'BLOCKED: ' + e.message);
            }
            
            // Test popup
            try {
                const testUrl = 'about:blank';
                const w = window.open(testUrl, 'test-popup');
                if (w) {
                    debugLog('‚úÖ window.open', 'ALLOWED');
                    w.close();
                } else {
                    debugLog('‚ö†Ô∏è window.open', 'BLOCKED (popup blocker)');
                }
            } catch (e) {
                debugLog('‚ùå window.open', 'BLOCKED: ' + e.message);
            }
            
            // Test localStorage
            try {
                localStorage.setItem('test', 'value');
                localStorage.removeItem('test');
                debugLog('‚úÖ localStorage', 'ALLOWED');
            } catch (e) {
                debugLog('‚ùå localStorage', 'BLOCKED: ' + e.message);
            }
        }

        // GENERATE SPIKE INJECTION CODE WITH ALTERNATIVE KEY COMBINATIONS
        function generateSpikeInjectionCode() {
            const injectionCode = `javascript:(function(){
    console.log('üöÄ Spike Editor Caret Listener Injected');
    
    // Remove any existing listeners
    if (window.spikeCaretListener) {
        document.removeEventListener('keydown', window.spikeCaretListener);
    }
    
    // Create new listener with multiple key combinations
    window.spikeCaretListener = function(e) {
        let keyMatched = false;
        let keyCombo = '';
        
        // Try multiple key combinations for Lightspeed compatibility
        if (e.ctrlKey && e.altKey && e.key.toLowerCase() === 'r') {
            keyMatched = true;
            keyCombo = 'Ctrl+Alt+R';
        } else if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'r') {
            keyMatched = true;
            keyCombo = 'Ctrl+Shift+R';
        } else if (e.altKey && e.shiftKey && e.key.toLowerCase() === 'r') {
            keyMatched = true;
            keyCombo = 'Alt+Shift+R';
        } else if (e.ctrlKey && e.key === 'F9') {
            keyMatched = true;
            keyCombo = 'Ctrl+F9';
        }
        
        if (keyMatched) {
            e.preventDefault();
            console.log('üìç ' + keyCombo + ' pressed in SPIKE editor');
            
            // Try to get caret position (simplified)
            const activeElement = document.activeElement;
            let caretColumn = 0;
            
            // Basic caret detection
            if (activeElement && activeElement.selectionStart !== undefined) {
                const text = activeElement.value || '';
                const start = activeElement.selectionStart;
                const lineStart = text.lastIndexOf('\\n', start - 1) + 1;
                caretColumn = start - lineStart;
            }
            
            console.log('üìç Detected caret column:', caretColumn);
            
            // Try multiple communication methods
            try {
                // Method 1: PostMessage to opener
                if (window.opener) {
                    window.opener.postMessage({
                        type: 'spike-caret', 
                        column: caretColumn
                    }, '*');
                    console.log('‚úÖ Sent via postMessage to opener');
                }
            } catch (e) {
                console.log('‚ùå postMessage to opener failed:', e);
            }
            
            try {
                // Method 2: BroadcastChannel
                const bc = new BroadcastChannel('spike-caret-column');
                bc.postMessage(caretColumn);
                bc.close();
                console.log('‚úÖ Sent via BroadcastChannel');
            } catch (e) {
                console.log('‚ùå BroadcastChannel failed:', e);
            }
            
            alert('Caret position sent: ' + caretColumn + ' (using ' + keyCombo + ')');
        }
    };
    
    document.addEventListener('keydown', window.spikeCaretListener);
    console.log('‚úÖ Listener attached - Try: Ctrl+Alt+R, Ctrl+Shift+R, Alt+Shift+R, or Ctrl+F9');
    alert('SPIKE Caret Listener Active!\\n\\nTry these key combinations in the code editor:\\n‚Ä¢ Ctrl+Alt+R\\n‚Ä¢ Ctrl+Shift+R\\n‚Ä¢ Alt+Shift+R\\n‚Ä¢ Ctrl+F9');
})();`;

            // Create a text area with the code for easy copying
            const textarea = document.createElement('textarea');
            textarea.value = injectionCode;
            textarea.style.position = 'fixed';
            textarea.style.top = '50px';
            textarea.style.left = '50px';
            textarea.style.width = '80%';
            textarea.style.height = '300px';
            textarea.style.zIndex = '9999';
            textarea.style.background = '#fff';
            textarea.style.border = '2px solid #333';
            document.body.appendChild(textarea);
            textarea.select();

            debugLog('üíæ SPIKE Injection Code Generated', 'Copy code and paste in SPIKE address bar');
            
            // Auto-remove after 30 seconds
            setTimeout(() => {
                if (document.body.contains(textarea)) {
                    document.body.removeChild(textarea);
                }
            }, 30000);
        }

        // MANUAL COPY DIALOG FOR LIGHTSPEED CHROMEBOOK
        function showManualCopyDialog(preparedText, rawText) {
            // Create overlay for manual copy
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
                align-items: center; justify-content: center;
            `;
            
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                background: white; padding: 20px; border-radius: 8px; max-width: 80%;
                max-height: 80%; overflow: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            `;
            
            dialog.innerHTML = `
                <h3>üîí Clipboard API Blocked - Manual Copy Required</h3>
                <p><strong>Lightspeed has blocked automatic clipboard access.</strong></p>
                <p>1. The text below is already selected</p>
                <p>2. Copy it with <strong>Ctrl+C</strong></p>
                <p>3. Switch to SPIKE editor and paste with <strong>Ctrl+V</strong></p>
                <textarea id="manual-copy-text" readonly style="
                    width: 100%; height: 200px; font-family: monospace; 
                    font-size: 14px; margin: 10px 0; border: 2px solid #007bff;
                ">${preparedText}</textarea>
                <div style="margin-top: 10px;">
                    <button id="close-manual-copy" style="background: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-right: 8px;">Close & Insert to Page</button>
                    <button id="select-all-text" style="background: #007bff; color: white; padding: 8px 16px; border: none; border-radius: 4px;">Re-select Text</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Auto-select the text
            const textarea = document.getElementById('manual-copy-text');
            textarea.focus();
            textarea.select();
            
            // Button handlers
            document.getElementById('close-manual-copy').onclick = () => {
                document.body.removeChild(overlay);
                // Still do the in-page insert
                processAndInsertText(rawText);
            };
            
            document.getElementById('select-all-text').onclick = () => {
                textarea.focus();
                textarea.select();
            };
            
            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.body.removeChild(overlay);
                    processAndInsertText(rawText);
                }
            };
            
            // Close on Escape key
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    document.removeEventListener('keydown', escHandler);
                    if (document.body.contains(overlay)) {
                        document.body.removeChild(overlay);
                        processAndInsertText(rawText);
                    }
                }
            };
            document.addEventListener('keydown', escHandler);
            
            debugLog('üìã Manual copy dialog shown', 'Text ready for Ctrl+C');
        }

        // GitHub release fetcher
        async function fetchGitHubRelease() {
            try {
                const response = await fetch('https://api.github.com/repos/edking21/Spike-Editor/releases/latest');

                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}`;
                    if (response.status === 404) {
                        errorMessage = 'Repository not found or no releases available';
                    } else if (response.status === 403) {
                        errorMessage = 'API rate limit exceeded';
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json();

                const releaseElement = document.getElementById('github-release');
                const publishedDate = new Date(data.published_at).toLocaleDateString();

                releaseElement.innerHTML = `
                    <a href="${data.html_url}" target="_blank" style="color: #0366d6; text-decoration: none;">
                        ${data.tag_name} - ${data.name}
                    </a> 
                    <span style="color: #666; font-size: 0.9em;">(${publishedDate})</span>
                `;
            } catch (error) {
                console.error('Failed to fetch GitHub release:', error);
                const releaseElement = document.getElementById('github-release');

                if (error.message.includes('Repository not found')) {
                    releaseElement.innerHTML = '<strong>GitHub Release:</strong> <span style="color: #666;">Repository not found or private</span>';
                } else {
                    releaseElement.innerHTML = '<strong>GitHub Release:</strong> <span style="color: #666;">Unable to load release info</span>';
                }
            }
        }

        // Track the last-focused editable element (textarea/input/contentEditable)
        window.__lastEditable = null;
        document.addEventListener('focusin', (ev) => {
            try {
                const t = ev.target;
                if (!t) return;
                const tag = (t.tagName || '').toLowerCase();
                if (tag === 'textarea' || (tag === 'input' && /text|search|url|email|password/.test(t.type)) || t.isContentEditable) {
                    window.__lastEditable = t;
                }
            } catch (e) { }
        });

        const snippetData = {
            1: {
                snippets: [
                    {
                        id: "m1",
                        buttonText: 'Run shortest distance to absolute 0',
                        emoji: 'üßø',
                        color: '#0000FF',
                        textPython: `
# Run shortest distance to absolute 0
await motor.run_to_absolute_position(port.E, 0, 200, direction=motor.SHORTEST_PATH)`
                    }
                ]
            },  // motors

            2: {
                snippets: [
                    {
                        id: "move1",
                        buttonText: 'move forward for 10cm',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# move forward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10*21, 0)`
                    },
                    {
                        id: "move2",
                        buttonText: 'move backward for 10cm',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# move backward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -10*21, 0)`
                    },
                    {
                        id: "move3",
                        buttonText: 'start moving',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# start moving
motor_pair.move(motor_pair.PAIR_1, 0)`
                    },
                    {
                        id: "move4",
                        buttonText: 'turn in place right 90',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# turn in place right 90 (180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 180, 100)`
                    },
                    {
                        id: "move5",
                        buttonText: 'turn in place left 90',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# turn in place left 90 (-180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -180, 100)`
                    },
                    {
                        id: "move6",
                        buttonText: 'pivot turn right 90 degrees',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn right 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 50)`
                    },
                    {
                        id: "move7",
                        buttonText: 'pivot turn left 90 degrees',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn left 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -360, 50)`
                    },
                    {
                        id: "move8",
                        buttonText: 'stop moving',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# stop moving
motor_pair.stop(motor_pair.PAIR_1)`
                    },
                    {
                        id: "move9",
                        buttonText: 'set movement speed to 50%',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# set movement speed to 50%
movement_speed = int(0.5 * 1100)`
                    },
                    {
                        id: "move10",
                        buttonText: 'set movement motors to C+D',
                        emoji: 'üßø',
                        color: '#FF4CCD',
                        textPython: `
# set movement motors to C+D
motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)`
                    }
                ]
            },  // Movement

            3: {
                snippets: [
                    {
                        id: "light1",
                        buttonText: 'Turn On Smiley Face For 2 Seconds',
                        emoji: 'üßø',
                        color: '#544AAC',
                        textPython: `
# Turn On Smiley Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_SMILE)
sleep(2)`
                    },
                    {
                        id: "light2",
                        buttonText: 'Blinking Eyes',
                        emoji: 'üßø',
                        color: '#544AAC',
                        textPython: `
# Blinking Eyes on the light matrix
blinking_eyes()`
                    },
                    {
                        id: "light3",
                        buttonText: 'Turn On Angry Face For 2 Seconds',
                        emoji: 'üßø',
                        color: '#544AAC',
                        textPython: `
# Turn On Angry Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_ANGRY)
sleep(2)`
                    }
                ]
            },  // light

            5: {
                snippets: [
                    {
                        id: "ctrl1",
                        buttonText: 'Wait for 1 second',
                        emoji: 'üßø',
                        color: '#E0C83C',
                        textPython: `
# Wait for 1 second
sleep(1)`
                    },
                    {
                        id: "ctrl2",
                        buttonText: 'Wait For Force Sensor Pressed',
                        emoji: 'üßø',
                        color: '#E0C83C',
                        textPython: `
# Wait For Force Sensor Pressed
while force_sensor.force(port.A) < 1: pass`
                    }
                ]
            },  // Control

            6: {
                snippets: [
                    {
                        id: "sens1",
                        buttonText: 'Distance Check (example)',
                        emoji: 'üßø',
                        color: '#34CCF1',
                        textPython: `
# Example sensor check
if distance_sensor.get_distance() < 10:
print('close')`
                    }
                ]
            },  // Sensor

            7: {
                snippets: [
                    {
                        id: "op1",
                        buttonText: 'Operator Example',
                        emoji: 'üßø',
                        color: '#6AA84F',
                        textPython: `
# Operator example
result = a + b  `
                    }
                ]
            },  // Operators

            8: {
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Getting Started',
                        emoji: 'üßø',
                        color: '#E31A1A',
                        textPython: `# ChallengeName
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light_matrix, port, sound
from time import sleep, sleep_ms
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

runloop.run(main())
sys.exit()    
`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Distance Sensor',
                        emoji: 'üßø',
                        color: '#E31A1A',
                        textPython: `
# Move forward until object within 10cm
if distance_sensor.distance(port.B) > 100 or distance_sensor.distance(port.B) == -1: pass`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Blinking Eyes (function)',
                        emoji: 'üßø',
                        color: '#E31A1A',
                        textPython: `
def blinking_eyes():
    # Show a blinking eyes animation on the Light Matrix
    for i in range(3):
        light_matrix.show_image(light_matrix.IMAGE_HAPPY)
        sleep_ms(1000)
        
        light_matrix.show_image(light_matrix.IMAGE_SMILE)
        sleep_ms(200)

    light_matrix.show_image(light_matrix.IMAGE_HAPPY)
    sleep_ms(2000)
    `
                    }
                ]
            }   // Functions
        };

        // Central setter for SPIKE caret column so we don't lose it
        function setSpikeCaretCol(col, source) {
            const n = Math.max(0, (col | 0));
            window.__spikeCaretCol = n;
            
            // Debug output
            debugLog('üéØ Setting SPIKE caret column', { column: n, source: source });
            
            // Update UI indicator and auto-select Spike mode so caretSpaces is used
            try {
                const ind = document.getElementById('spike-caret-indicator');
                if (ind) ind.textContent = `Spike caret: ${n}`;
                const radios = document.querySelectorAll('input[name="clipmode"]');
                radios.forEach(r => { if (r.value === 'spike') r.checked = true; });
            } catch (_) { }
            try {
                const ts = new Date().toLocaleTimeString();
                console.log(`[SPIKE caret] Set to ${n} from ${source} at ${ts}`);
            } catch (_) {
                console.log('[SPIKE caret] Set to', n, 'from', source);
            }
        }

        // Get the caret column (0-based) from the last-focused editable control (textarea/input/contentEditable)
        function getCaretColumnFromActiveEditable() {
            const el = window.__lastEditable || document.getElementById('t');
            if (!el) return 0;

            // Textarea or text-like input
            const isTextInput = el && (el.tagName || '').toLowerCase() === 'textarea' || ((el.tagName || '').toLowerCase() === 'input' && /text|search|url|email|password/.test(el.type));
            if (isTextInput) {
                const v = el.value || '';
                const selStart = typeof el.selectionStart === 'number' ? el.selectionStart : 0;
                const lineStart = v.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                return Math.max(0, selStart - lineStart);
            }

            // contentEditable (best-effort fallback): return 0 if we can't compute
            try {
                const sel = window.getSelection();
                if (sel && sel.rangeCount) {
                    const range = sel.getRangeAt(0);
                    // naive: count chars since last newline in the textContent of the current block
                    const container = range.startContainer;
                    const textBefore = container.textContent ? container.textContent.slice(0, range.startOffset) : '';
                    const lastNl = textBefore.lastIndexOf('\n');
                    return lastNl >= 0 ? (textBefore.length - 1 - lastNl) : textBefore.length;
                }
            } catch (_) { }
            return 0;
        }

        // Build clipboard text so lines 2..n are padded to align under the caret column; first line starts at caret
        function buildClipboardTextSubsequentOnly(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (!lines.length) return '';
            const out = new Array(lines.length);
            // First line: no padding so it starts at caret
            out[0] = lines[0] || '';
            for (let i = 1; i < lines.length; i++) {
                out[i] = pad + lines[i];
            }
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Build clipboard text so ALL lines are shifted to start at the caret column (pads every line)
        function buildClipboardTextAllLinesCaretShift(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const out = lines.map(line => pad + line);
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Ensure this tab is focused before attempting clipboard operations (required by browsers)
        async function ensureThisTabFocused(timeoutMs = 300) {
            if (document.hasFocus && document.hasFocus()) return true;
            try { window.focus(); } catch (_) { }
            // Wait briefly for a focus event or timeout
            return await new Promise((resolve) => {
                let settled = false;
                const done = (val) => { if (!settled) { settled = true; resolve(val); } };
                const onFocus = () => { window.removeEventListener('focus', onFocus); done(true); };
                window.addEventListener('focus', onFocus, { once: true });
                setTimeout(() => {
                    window.removeEventListener('focus', onFocus);
                    done(document.hasFocus ? document.hasFocus() : true);
                }, timeoutMs);
            });
        }

        // Keep a handle to the SPIKE window if opened, so we can focus it later
        function getSpikeWindow() {
            const w = window.__spikeWin;
            return w && !w.closed ? w : null;
        }
        function tryFocusSpikeWindow() {
            let w = getSpikeWindow();
            if (!w) {
                // Try to attach to an existing named window if user opened SPIKE manually
                try {
                    w = window.open('', 'spike-editor-tab');
                    if (w) window.__spikeWin = w;
                } catch (_) { /* noop */ }
            }
            if (!w) return false;
            try { w.focus(); return true; } catch (_) { return false; }
        }

        // Copy plain text to clipboard with fallback
        async function copyPlainText(text) {
            try {
                // The async Clipboard API generally requires the calling document to be focused
                await ensureThisTabFocused(300);
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (err) {
                console.log('[Clipboard] navigator.clipboard.writeText error:', err);
                // fall through to legacy fallback below
            }
            try {
                const tmp = document.createElement('textarea');
                tmp.value = text;
                tmp.setAttribute('readonly', '');
                tmp.style.position = 'fixed';
                tmp.style.opacity = '0';
                tmp.style.pointerEvents = 'none';
                document.body.appendChild(tmp);
                tmp.focus();
                tmp.select();
                const ok = document.execCommand('copy');
                document.body.removeChild(tmp);
                return ok;
            } catch (_) {
                return false;
            }
        }

        // Determine clipboard alignment mode from the UI controls
        function getClipboardAlignMode() {
            const radios = document.querySelectorAll('input[name="clipmode"]');
            let mode = 'raw';
            radios.forEach(r => { if (r.checked) mode = r.value; });
            if (mode === 'column') {
                const v = parseInt((document.getElementById('clip-column') || {}).value, 10);
                return { mode, column: isNaN(v) ? 0 : Math.max(0, v) };
            }
            return { mode };
        }

        // Build clipboard text based on the selected mode
        function buildClipboardFromMode(text) {
            const { mode, column } = getClipboardAlignMode();
            if (mode === 'raw') {
                // No indentation adjustments; normalize to CRLF for Windows editors
                return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
            }
            if (mode === 'caret') {
                const caretCol = getCaretColumnFromActiveEditable();
                return buildClipboardTextAllLinesCaretShift(text, caretCol);
            }
            if (mode === 'spike') {
                const spikeCol = (typeof window.__spikeCaretCol === 'number') ? window.__spikeCaretCol : null;
                if (spikeCol === null) {
                    console.warn('[SPIKE caret] Spike mode selected but no caret received yet; defaulting to 0.');
                } else {
                    console.log('[SPIKE caret] Using caretSpaces =', spikeCol);
                }
                return buildClipboardTextAllLinesCaretShift(text, spikeCol ?? 0);
            }
            if (mode === 'column') {
                return buildClipboardTextAllLinesCaretShift(text, column || 0);
            }
            return (text || '');
        }

        // UPDATED MAIN FUNCTION WITH LIGHTSPEED FALLBACK
        async function copySnippetWithLineInsert(preId) {
            const el = document.getElementById(preId);
            if (!el) {
                console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
                alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
                return;
            }

            const raw = el.textContent || '';

            // Debug: show current mode and spike caret prior to building clipboard
            const modeSnapshot = getClipboardAlignMode();
            debugLog('üìã Clipboard copy initiated', { mode: modeSnapshot, spikeCaretCol: window.__spikeCaretCol });

            // Build clipboard according to selected align mode
            const prepared = buildClipboardFromMode(raw);
            
            // TRY CLIPBOARD API FIRST, FALLBACK TO MANUAL SELECTION
            const copied = await copyPlainText(prepared);
            
            if (!copied) {
                // LIGHTSPEED CHROMEBOOK FALLBACK - Show text for manual copying
                debugLog('‚ùå Clipboard API blocked - showing manual copy option', 'User must copy manually');
                showManualCopyDialog(prepared, raw);
                return;
            }

            // In-page insert: still insert raw so first line is at caret and others align
            processAndInsertText(raw);

            // After copying, bring the SPIKE window to the front for quick paste
            const spikeFocused = tryFocusSpikeWindow();
            const focusHint = spikeFocused ? '' : '\n\nTip: Couldn\'t bring SPIKE to front‚ÄîAlt+Tab to it and paste.';

            alert('Clipboard ready. Move to your target editor and paste.' + focusHint);
        }

        function refreshSnippets(buttonId) {
            const column = document.getElementById('snippet-column');
            column.innerHTML = '';

            const data = snippetData[buttonId];
            if (!data) return;

            data.snippets.forEach((snippet, index) => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet movement';
                const preId = `snippet-${buttonId}-${index}`;
                const pre = document.createElement('pre');
                pre.id = preId;
                pre.contentEditable = true;
                pre.style.display = 'none';
                const parts = [];
                parts.push(snippet.textPython);
                pre.textContent = parts.join('\n') + '\n';

                snippetDiv.appendChild(pre);

                const button = document.createElement('button');
                // emoji slightly larger via CSS class
                button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
                button.style.backgroundColor = snippet.color;
                button.style.color = '#ffffff';
                button.title = snippet.buttonText; // keep accessible label

                // Click inserts into textarea and prepares clipboard with proper indentation for external paste
                button.addEventListener('click', () => copySnippetWithLineInsert(preId));

                snippetDiv.appendChild(button);
                column.appendChild(snippetDiv);
            });
        }

        // Insert multiline text with caret-relative indentation into #t on paste; expose processAndInsertText.
        (function () {
            const ta = document.getElementById('t');

            function processAndInsertText(inputText) {
                if (!inputText) return; // nothing to do

                const value = ta.value;
                const selStart = ta.selectionStart;
                const selEnd = ta.selectionEnd;

                // find start index of the current line where the caret is (or selection start)
                const lineStart = value.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                const caretColumn = selStart - lineStart; // number of characters from line start to caret

                // build the padding string (spaces). If you prefer tabs, change this.
                const pad = ' '.repeat(caretColumn);

                // Normalize newlines in inputText (handles CRLF)
                const pastedLines = inputText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

                // If the user is replacing a selection, the first pasted line should be inserted at selStart,
                // so we do not prefix the first line. Only subsequent lines get the pad prefixed.
                for (let i = 1; i < pastedLines.length; i++) {
                    pastedLines[i] = pad + pastedLines[i];
                }

                const toInsert = pastedLines.join('\n');

                // Replace selection with our processed text
                const newValue = value.slice(0, selStart) + toInsert + value.slice(selEnd);
                ta.value = newValue;

                // compute new caret position: place caret just after the inserted content
                const newCaretPos = selStart + toInsert.length;
                ta.setSelectionRange(newCaretPos, newCaretPos);
                // optional: trigger input event if other code listens for it
                ta.dispatchEvent(new Event('input', { bubbles: true }));
            }

            ta.addEventListener('paste', function (ev) {
                // get plain text from clipboard
                const clipboardText = (ev.clipboardData || window.clipboardData).getData('text');
                ev.preventDefault(); // we'll insert our processed text
                processAndInsertText(clipboardText);
            });

            // insert multiline text into the textarea at caret position with proper indentation
            window.processAndInsertText = processAndInsertText;
        })();

        document.addEventListener('DOMContentLoaded', () => {
            debugLog('üöÄ Spike Editor loaded and ready');
            debugLog('üëÇ Listening for messages from', 'https://spike.legoeducation.com');
            refreshSnippets(1);
            fetchGitHubRelease(); // Fetch release info on page load

            // SET UP TESTING BUTTONS
            document.getElementById('test-keys').addEventListener('click', startKeyTesting);
            
            document.getElementById('send-test-caret').addEventListener('click', () => {
                const testColumn = 4;
                debugLog('üì§ Manually sending test caret', { column: testColumn });
                setSpikeCaretCol(testColumn, 'Manual test button');
            });
            
            document.getElementById('manual-caret-input').addEventListener('click', () => {
                const column = prompt('Enter caret column number:', '0');
                if (column !== null) {
                    const col = parseInt(column, 10);
                    if (!isNaN(col)) {
                        setSpikeCaretCol(col, 'Manual input');
                        debugLog('‚úèÔ∏è Manual caret set', { column: col });
                    }
                }
            });
            
            document.getElementById('test-restrictions').addEventListener('click', testLightspeedRestrictions);
            document.getElementById('inject-spike-listener').addEventListener('click', generateSpikeInjectionCode);
        });

        // SPIKE editor caret column support
        // BroadcastChannel 'spike-caret-column' is used to receive caret column updates from other tabs or windows
        // specifically for SPIKE editor integration. This channel is dedicated to transmitting only the caret column
        // as a number, whereas the 'spike-caret' channel may transmit more complex messages (objects with type and column).
        (function () {
            const bc = new BroadcastChannel('spike-caret-column');
            bc.onmessage = (ev) => {
                if (typeof ev.data === 'number') {
                    setSpikeCaretCol(ev.data, 'BroadcastChannel: spike-caret-column');
                }
            };
        })();

        // Shared channel to receive caret column from the SPIKE editor tab (same-origin only)
        const spikeChannel = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('spike-caret') : null;
        window.__spikeCaretCol = null; // initialize once
        if (spikeChannel) {
            spikeChannel.onmessage = (ev) => {
                try {
                    const data = ev.data;
                    if (data && data.type === 'caret' && typeof data.column === 'number') {
                        setSpikeCaretCol(data.column, 'BroadcastChannel: spike-caret');
                    }
                } catch (err) {
                    console.log('[SPIKE caret] BroadcastChannel onmessage error:', err);
                    alert('Error processing message from SPIKE editor. See console for details.');
                    // continue without interrupting fallback mechanisms
                }
            };
        }

         // Cross-tab caret receiver via postMessage from SPIKE tab
        // ENHANCED WITH DEBUG LOGGING FOR LIGHTSPEED CHROMEBOOK
        window.addEventListener('message', (ev) => {
            try {
                // Debug: Log ALL incoming messages first
                debugLog('üì® Received postMessage', {
                    origin: ev.origin,
                    data: ev.data,
                    type: typeof ev.data
                });

                // Accept messages from Google Sites (for testing) AND SPIKE
                const ALLOWED_ORIGINS = new Set([
                    'https://spike.legoeducation.com',
                    'https://sites.google.com'  // Add Google Sites for testing
                ]);
                
                if (!ALLOWED_ORIGINS.has(ev.origin)) {
                    debugLog('üö´ Ignoring message from untrusted origin', ev.origin);
                    return;
                }

                debugLog('‚úÖ Processing message from trusted origin', ev.origin);

                // Accept either a structured object { type:'spike-caret', column:number }
                // or a plain number (column) for simple integrations.
                const d = ev.data;
                let col = null;
                
                // Handle test messages from Google Sites injector
                if (d && typeof d === 'object' && d.type === 'test-key-pressed') {
                    debugLog('üéπ KEY TEST MESSAGE', { 
                        key: d.key, 
                        column: d.column,
                        source: 'Google Sites Injector'
                    });
                    if (typeof d.column === 'number') {
                        col = d.column;
                    }
                }
                // Handle standard SPIKE caret messages
                else if (d && typeof d === 'object') {
                    if (d.type === 'spike-caret' && typeof d.column === 'number' && isFinite(d.column)) {
                        col = d.column;
                        debugLog('üìç Received structured caret message', { column: col });
                    }
                } else if (typeof d === 'number' && isFinite(d)) {
                    col = d;
                    debugLog('üìç Received numeric caret value', col);
                }

                if (col !== null) {
                    debugLog('üéØ SPIKE caret update SUCCESS', { column: col, origin: ev.origin });
                    setSpikeCaretCol(col, `postMessage: ${ev.origin}`);
                } else {
                    debugLog('‚ùì Unrecognized message payload', { data: d, origin: ev.origin });
                }
            } catch (err) {
                debugLog('üí• postMessage handler ERROR', err.message);
            }
        });

        // Helper to open SPIKE page with opener preserved (no noopener)
        document.getElementById('open-spike').addEventListener('click', () => {
            const url = 'https://spike.legoeducation.com/prime/project';
            // Open without noopener so window.opener is available for postMessage
            const w = window.open(url, 'spike-editor-tab');
            // Save handle for later focusing
            window.__spikeWin = w || window.__spikeWin;
            if (!w) {
                alert('Popup blocked. Please allow pop-ups for this site, then try again.');
            } else {
                debugLog('üîó Opened SPIKE editor', 'Window handle saved for communication');
                
                // Test communication after a delay
                setTimeout(() => {
                    try {
                        w.postMessage({
                            type: 'test-from-snippet-shelf',
                            message: 'Hello from Spike Editor'
                        }, 'https://spike.legoeducation.com');
                        debugLog('üì§ Sent test message to SPIKE tab', 'Testing cross-tab communication');
                    } catch (e) {
                        debugLog('‚ùå Failed to send test message to SPIKE tab', e.message);
                    }
                }, 3000);
            }
        });
    </script>
</body>

</html>