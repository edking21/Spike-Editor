<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Paste with caret-relative indentation</title>
  <style>
    textarea { width: 90%; height: 200px; font-family: monospace; font-size: 14px; }
  </style>
</head>
<body>
      <!-- Left column with emoji buttons -->
  <div class="left-column">
    <div class="emoji-block">
      <div class="emoji-container"><button onclick="refreshSnippets(1)">ðŸ”µ</button><div class="emoji-label">Motors</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(2)">ðŸ”´</button><div class="emoji-label">Movement</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(3)">ðŸŸ£</button><div class="emoji-label">Light</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(4)">ðŸŸ¡</button><div class="emoji-label">Events</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(5)">ðŸŸ¡</button><div class="emoji-label">Control</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(6)">ðŸ”µ</button><div class="emoji-label">Sensors</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(7)">ðŸŸ¢</button><div class="emoji-label">Operators</div></div>
      <div class="emoji-container"><button onclick="refreshSnippets(8)">ðŸ”´</button><div class="emoji-label">Functions</div></div>
    </div>
  </div>

  <div class="snippet-column" id="snippet-column">
    <!-- Snippets will be dynamically inserted here -->
  </div>

  <p>Place the caret somewhere in a line, then paste multiline text. Subsequent pasted lines will be indented to the caret column.</p>
  <textarea id="t"></textarea>

<script>
    // Track the last-focused editable element (textarea/input/contentEditable)
    window.__lastEditable = null;
    document.addEventListener('focusin', (ev) => {
      try {
        const t = ev.target;
        if (!t) return;
        const tag = (t.tagName || '').toLowerCase();
        if (tag === 'textarea' || (tag === 'input' && /text|search|url|email|password/.test(t.type)) || t.isContentEditable) {
          window.__lastEditable = t;
        }
      } catch (e) {}
    });
    // Cleaned-up snippetData: no duplicate keys, no stray concatenation plus signs
    const snippetData = {
1: { snippets: [
{
id: "m1",
buttonText: 'Run shortest distance to absolute 0',
emoji: 'ðŸ§¿',
color: '#0000FF',
textPython: `
# Run shortest distance to absolute 0
await motor.run_to_absolute_position(port.E, 0, 200, direction=motor.SHORTEST_PATH)`
}
]},  // motors

2: { snippets: [
{
id: "move1",
buttonText: 'move forward for 10cm',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# move forward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10*21, 0)`
},
{
id: "move2",
buttonText: 'move backward for 10cm',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# move backward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -10*21, 0)`
},
{
id: "move3",
buttonText: 'start moving',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# start moving
motor_pair.move(motor_pair.PAIR_1, 0)`
},
{
id: "move4",
buttonText: 'turn in place right 90',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# turn in place right 90 (180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 180, 100)`
}, 
{
id: "move5",
buttonText: 'turn in place left 90',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# turn in place left 90 (-180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -180, 100)`
}, 
{
id: "move6",
buttonText: 'pivot turn right 90 degrees',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# pivot turn right 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 50)`
},
{
id: "move7",
buttonText: 'pivot turn left 90 degrees',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# pivot turn left 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -360, 50)`
},
{
id: "move8",
buttonText: 'stop moving',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# stop moving
motor_pair.stop(motor_pair.PAIR_1)`
},
{
id: "move9",
buttonText: 'set movement speed to 50%',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# set movement speed to 50%
movement_speed = int(0.5 * 1100)`
},
{
id: "move10",
buttonText: 'set movement motors to C+D',
emoji: 'ðŸ§¿',
color: '#FF4CCD',
textPython: `
# set movement motors to C+D
motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)`
}
]},  // Movement

3: { snippets: [
{
id: "light1",
buttonText: 'Turn On Smiley Face For 2 Seconds',
emoji: 'ðŸ§¿',
color: '#544AAC',
textPython: `
# Turn On Smiley Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_SMILE)
sleep(2)`
},
{
id: "light2",
buttonText: 'Blinking Eyes',
emoji: 'ðŸ§¿',
color: '#544AAC',
textPython: `
# Blinking Eyes on the light matrix
blinking_eyes()`
},
{
id: "light3",
buttonText: 'Turn On Angry Face For 2 Seconds',
emoji: 'ðŸ§¿',
color: '#544AAC',
textPython: `
# Turn On Angry Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_ANGRY)
sleep(2)`
}
]},  // light

5: { snippets: [
{
id: "ctrl1",
buttonText: 'Wait for 1 second',
emoji: 'ðŸ§¿',
color: '#E0C83C',
textPython: `
# Wait for 1 second
sleep(1)`
},
{
id: "ctrl2",
buttonText: 'Wait For Force Sensor Pressed',
emoji: 'ðŸ§¿',
color: '#E0C83C',
textPython: `
# Wait For Force Sensor Pressed
while force_sensor.force(port.A) < 1: pass`
}
]},  // Control

6: { snippets: [
{
id: "sens1",
buttonText: 'Distance Check (example)',
emoji: 'ðŸ§¿',
color: '#34CCF1',
textPython: `
# Example sensor check
if distance_sensor.get_distance() < 10:
print('close')`
}
]},  // Sensor

7: { snippets: [
{
id: "op1",
buttonText: 'Operator Example',
emoji: 'ðŸ§¿',
color: '#6AA84F',
textPython: `
# Operator example
result = a + b  `
}
]},  // Operators

8: { snippets: [
{
id: "fn1",
buttonText: 'Getting Started',
emoji: 'ðŸ§¿',
color: '#E31A1A',
textPython:`# ChallengeName
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light_matrix, port, sound
from time import sleep, sleep_ms
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

runloop.run(main())
sys.exit()    
`
},
{
id: "fn2",
buttonText: 'Distance Sensor',
emoji: 'ðŸ§¿',
color: '#E31A1A',
textPython: `
# Move forward until object within 10cm
if distance_sensor.distance(port.B) > 100 or distance_sensor.distance(port.B) == -1: pass`
},
{
id: "fn2",
buttonText: 'Blinking Eyes (function)',
emoji: 'ðŸ§¿',
color: '#E31A1A',
textPython: `
def blinking_eyes():
    # Show a blinking eyes animation on the Light Matrix
    for i in range(3):
        light_matrix.show_image(light_matrix.IMAGE_HAPPY)
        sleep_ms(1000)
        
        light_matrix.show_image(light_matrix.IMAGE_SMILE)
        sleep_ms(200)

    light_matrix.show_image(light_matrix.IMAGE_HAPPY)
    sleep_ms(2000)
    `
}
]}   // Functions
};    
   
    // Main function split for readability
    // Main function split for readability
    function copySnippetWithLineInsert(preId) {

        const el = document.getElementById(preId);
        if (!el) {
            console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
            alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
            return;
        }
    
        const text = el.textContent || '';
        processAndInsertText(text);
        
        return;
    }
    function refreshSnippets(buttonId) {
      const column = document.getElementById('snippet-column');
      column.innerHTML = '';

      const data = snippetData[buttonId];
      if (!data) return;

      data.snippets.forEach((snippet, index) => {
        const snippetDiv = document.createElement('div');
        snippetDiv.className = 'snippet movement';
        const preId = `snippet-${buttonId}-${index}`;
        const pre = document.createElement('pre');
        pre.id = preId;
        pre.contentEditable = true;
        pre.style.display = 'none';
        const parts = [];
        parts.push(snippet.textPython);
        pre.textContent = parts.join('\n') + '\n';
        // pre.textContent = '\n' + parts.join('\n') + '\n';

        snippetDiv.appendChild(pre);

        const button = document.createElement('button');
        // emoji slightly larger via CSS class
        button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
        button.style.backgroundColor = snippet.color;
        button.style.color = '#ffffff';
        button.title = snippet.buttonText; // keep accessible label

        button.addEventListener('click', () => copySnippetWithLineInsert(preId));

        snippetDiv.appendChild(button);
        column.appendChild(snippetDiv);
      });
    }

  (function(){
    const ta = document.getElementById('t');

    function processAndInsertText(inputText) {
        if (!inputText) return; // nothing to do

        const value = ta.value;
        const selStart = ta.selectionStart;
        const selEnd = ta.selectionEnd;

        // find start index of the current line where the caret is (or selection start)
        const lineStart = value.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
        const caretColumn = selStart - lineStart; // number of characters from line start to caret

        // build the padding string (spaces). If you prefer tabs, change this.
        const pad = ' '.repeat(caretColumn);

        // Normalize newlines in inputText (handles CRLF)
        const pastedLines = inputText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

        // If the user is replacing a selection, the first pasted line should be inserted at selStart,
        // so we do not prefix the first line. Only subsequent lines get the pad prefixed.
        for (let i = 1; i < pastedLines.length; i++) {
            pastedLines[i] = pad + pastedLines[i];
        }

        const toInsert = pastedLines.join('\n');

        // Replace selection with our processed text
        const newValue = value.slice(0, selStart) + toInsert + value.slice(selEnd);
        ta.value = newValue;

        // compute new caret position: place caret just after the inserted content
        const newCaretPos = selStart + toInsert.length;
        ta.setSelectionRange(newCaretPos, newCaretPos);
        // optional: trigger input event if other code listens for it
        ta.dispatchEvent(new Event('input', { bubbles: true }));
    }

    ta.addEventListener('paste', function (ev) {
        // get plain text from clipboard
        const clipboardText = (ev.clipboardData || window.clipboardData).getData('text');
        ev.preventDefault(); // we'll insert our processed text
        processAndInsertText(clipboardText);
    });

    // Expose the function globally for external calls
    window.processAndInsertText = processAndInsertText;
})();

      document.addEventListener('DOMContentLoaded', () => refreshSnippets(1));

  </script>
</body>
</html>
