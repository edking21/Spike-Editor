<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Paste with caret-relative indentation</title>
    <style>
        textarea {
            width: 90%;
            height: 200px;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <!-- Left column with emoji buttons -->
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button onclick="refreshSnippets(1)">ðŸ”µ</button>
                <div class="emoji-label">Motors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(2)">ðŸ”´</button>
                <div class="emoji-label">Movement</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(3)">ðŸŸ£</button>
                <div class="emoji-label">Light</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(4)">ðŸŸ¡</button>
                <div class="emoji-label">Events</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(5)">ðŸŸ¡</button>
                <div class="emoji-label">Control</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(6)">ðŸ”µ</button>
                <div class="emoji-label">Sensors</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(7)">ðŸŸ¢</button>
                <div class="emoji-label">Operators</div>
            </div>
            <div class="emoji-container"><button onclick="refreshSnippets(8)">ðŸ”´</button>
                <div class="emoji-label">Functions</div>
            </div>
        </div>
    </div>

    <div style="margin: 8px 0; padding: 6px; border: 1px solid #ddd; max-width: 900px;">
        <strong>Clipboard align:</strong>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="raw" checked> Raw (no indent)
        </label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="caret"> Page caret</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="spike"> Spike caret (from other tab)</label>
        <label style="margin-left:8px;"><input type="radio" name="clipmode" value="column"> Column
            <input id="clip-column" type="number" min="0" value="0" style="width:4em; margin-left:4px;">
        </label>
        <button id="open-spike" style="margin-left:12px;">Open SPIKE Editor</button>
        <span style="margin-left:12px; color:#666;">This only affects the clipboard. In-page insert still aligns
            subsequent lines to the caret in the test area.</span>
    </div>

    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>

    <textarea id="t"></textarea>

    <script>
        // Track the last-focused editable element (textarea/input/contentEditable)
        window.__lastEditable = null;
        document.addEventListener('focusin', (ev) => {
            try {
                const t = ev.target;
                if (!t) return;
                const tag = (t.tagName || '').toLowerCase();
                if (tag === 'textarea' || (tag === 'input' && /text|search|url|email|password/.test(t.type)) || t.isContentEditable) {
                    window.__lastEditable = t;
                }
            } catch (e) { }
        });

        const snippetData = {
            1: {
                snippets: [
                    {
                        id: "m1",
                        buttonText: 'Run shortest distance to absolute 0',
                        emoji: 'ðŸ§¿',
                        color: '#0000FF',
                        textPython: `
# Run shortest distance to absolute 0
await motor.run_to_absolute_position(port.E, 0, 200, direction=motor.SHORTEST_PATH)`
                    }
                ]
            },  // motors

            2: {
                snippets: [
                    {
                        id: "move1",
                        buttonText: 'move forward for 10cm',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# move forward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 10*21, 0)`
                    },
                    {
                        id: "move2",
                        buttonText: 'move backward for 10cm',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# move backward for 10cm
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -10*21, 0)`
                    },
                    {
                        id: "move3",
                        buttonText: 'start moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# start moving
motor_pair.move(motor_pair.PAIR_1, 0)`
                    },
                    {
                        id: "move4",
                        buttonText: 'turn in place right 90',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# turn in place right 90 (180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 180, 100)`
                    },
                    {
                        id: "move5",
                        buttonText: 'turn in place left 90',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# turn in place left 90 (-180 degrees rotation 100 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -180, 100)`
                    },
                    {
                        id: "move6",
                        buttonText: 'pivot turn right 90 degrees',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn right 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, 360, 50)`
                    },
                    {
                        id: "move7",
                        buttonText: 'pivot turn left 90 degrees',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# pivot turn left 90 degrees (360 degrees rotation 50 percent steering
await motor_pair.move_for_degrees(motor_pair.PAIR_1, -360, 50)`
                    },
                    {
                        id: "move8",
                        buttonText: 'stop moving',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# stop moving
motor_pair.stop(motor_pair.PAIR_1)`
                    },
                    {
                        id: "move9",
                        buttonText: 'set movement speed to 50%',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# set movement speed to 50%
movement_speed = int(0.5 * 1100)`
                    },
                    {
                        id: "move10",
                        buttonText: 'set movement motors to C+D',
                        emoji: 'ðŸ§¿',
                        color: '#FF4CCD',
                        textPython: `
# set movement motors to C+D
motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)`
                    }
                ]
            },  // Movement

            3: {
                snippets: [
                    {
                        id: "light1",
                        buttonText: 'Turn On Smiley Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Turn On Smiley Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_SMILE)
sleep(2)`
                    },
                    {
                        id: "light2",
                        buttonText: 'Blinking Eyes',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Blinking Eyes on the light matrix
blinking_eyes()`
                    },
                    {
                        id: "light3",
                        buttonText: 'Turn On Angry Face For 2 Seconds',
                        emoji: 'ðŸ§¿',
                        color: '#544AAC',
                        textPython: `
# Turn On Angry Face For 2 Seconds
light_matrix.show_image(light_matrix.IMAGE_ANGRY)
sleep(2)`
                    }
                ]
            },  // light

            5: {
                snippets: [
                    {
                        id: "ctrl1",
                        buttonText: 'Wait for 1 second',
                        emoji: 'ðŸ§¿',
                        color: '#E0C83C',
                        textPython: `
# Wait for 1 second
sleep(1)`
                    },
                    {
                        id: "ctrl2",
                        buttonText: 'Wait For Force Sensor Pressed',
                        emoji: 'ðŸ§¿',
                        color: '#E0C83C',
                        textPython: `
# Wait For Force Sensor Pressed
while force_sensor.force(port.A) < 1: pass`
                    }
                ]
            },  // Control

            6: {
                snippets: [
                    {
                        id: "sens1",
                        buttonText: 'Distance Check (example)',
                        emoji: 'ðŸ§¿',
                        color: '#34CCF1',
                        textPython: `
# Example sensor check
if distance_sensor.get_distance() < 10:
print('close')`
                    }
                ]
            },  // Sensor

            7: {
                snippets: [
                    {
                        id: "op1",
                        buttonText: 'Operator Example',
                        emoji: 'ðŸ§¿',
                        color: '#6AA84F',
                        textPython: `
# Operator example
result = a + b  `
                    }
                ]
            },  // Operators

            8: {
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Getting Started',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `# ChallengeName
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light_matrix, port, sound
from time import sleep, sleep_ms
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

runloop.run(main())
sys.exit()    
`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Distance Sensor',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `
# Move forward until object within 10cm
if distance_sensor.distance(port.B) > 100 or distance_sensor.distance(port.B) == -1: pass`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Blinking Eyes (function)',
                        emoji: 'ðŸ§¿',
                        color: '#E31A1A',
                        textPython: `
def blinking_eyes():
    # Show a blinking eyes animation on the Light Matrix
    for i in range(3):
        light_matrix.show_image(light_matrix.IMAGE_HAPPY)
        sleep_ms(1000)
        
        light_matrix.show_image(light_matrix.IMAGE_SMILE)
        sleep_ms(200)

    light_matrix.show_image(light_matrix.IMAGE_HAPPY)
    sleep_ms(2000)
    `
                    }
                ]
            }   // Functions
        };

        // Get the caret column (0-based) from the last-focused editable control (textarea/input/contentEditable)
        function getCaretColumnFromActiveEditable() {
            const el = window.__lastEditable || document.getElementById('t');
            if (!el) return 0;

            // Textarea or text-like input
            const isTextInput = el && (el.tagName || '').toLowerCase() === 'textarea' || ((el.tagName || '').toLowerCase() === 'input' && /text|search|url|email|password/.test(el.type));
            if (isTextInput) {
                const v = el.value || '';
                const selStart = typeof el.selectionStart === 'number' ? el.selectionStart : 0;
                const lineStart = v.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                return Math.max(0, selStart - lineStart);
            }

            // contentEditable (best-effort fallback): return 0 if we can't compute
            try {
                const sel = window.getSelection();
                if (sel && sel.rangeCount) {
                    const range = sel.getRangeAt(0);
                    // naive: count chars since last newline in the textContent of the current block
                    const container = range.startContainer;
                    const textBefore = container.textContent ? container.textContent.slice(0, range.startOffset) : '';
                    const lastNl = textBefore.lastIndexOf('\n');
                    return lastNl >= 0 ? (textBefore.length - 1 - lastNl) : textBefore.length;
                }
            } catch (_) { }
            return 0;
        }

        // Build clipboard text so lines 2..n are padded to align under the caret column; first line starts at caret
        function buildClipboardTextSubsequentOnly(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            if (!lines.length) return '';
            const out = new Array(lines.length);
            // First line: no padding so it starts at caret
            out[0] = lines[0] || '';
            for (let i = 1; i < lines.length; i++) {
                out[i] = pad + lines[i];
            }
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Build clipboard text so ALL lines are shifted to start at the caret column (pads every line)
        function buildClipboardTextAllLinesCaretShift(text, caretSpaces) {
            const pad = ' '.repeat(Math.max(0, caretSpaces | 0));
            const lines = (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const out = lines.map(line => pad + line);
            // Return CRLF for Windows editors like Notepad++
            return out.join('\n').replace(/\n/g, '\r\n');
        }

        // Copy plain text to clipboard with fallback
        async function copyPlainText(text) {
            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
            } catch (_) { /* fall through */ }
            try {
                const tmp = document.createElement('textarea');
                tmp.value = text;
                tmp.setAttribute('readonly', '');
                tmp.style.position = 'fixed';
                tmp.style.opacity = '0';
                tmp.style.pointerEvents = 'none';
                document.body.appendChild(tmp);
                tmp.focus();
                tmp.select();
                const ok = document.execCommand('copy');
                document.body.removeChild(tmp);
                return ok;
            } catch (_) {
                return false;
            }
        }

        // Determine clipboard alignment mode from the UI controls
        function getClipboardAlignMode() {
            const radios = document.querySelectorAll('input[name="clipmode"]');
            let mode = 'raw';
            radios.forEach(r => { if (r.checked) mode = r.value; });
            if (mode === 'column') {
                const v = parseInt((document.getElementById('clip-column') || {}).value, 10);
                return { mode, column: isNaN(v) ? 0 : Math.max(0, v) };
            }
            return { mode };
        }

        // Build clipboard text based on the selected mode
        function buildClipboardFromMode(text) {
            const { mode, column } = getClipboardAlignMode();
            if (mode === 'raw') {
                // No indentation adjustments; normalize to CRLF for Windows editors
                return (text || '').replace(/\r\n/g, '\n').replace(/\r/g, '\n').replace(/\n/g, '\r\n');
            }
            if (mode === 'caret') {
                const caretCol = getCaretColumnFromActiveEditable();
                return buildClipboardTextAllLinesCaretShift(text, caretCol);
            }
            if (mode === 'spike') {
                const spikeCol = typeof window.__spikeCaretCol === 'number' ? window.__spikeCaretCol : 0;
                return buildClipboardTextAllLinesCaretShift(text, spikeCol);
            }
            if (mode === 'column') {
                return buildClipboardTextAllLinesCaretShift(text, column || 0);
            }
            return (text || '');
        }

        // Main function split for readability
        // Main function split for readability
        function copySnippetWithLineInsert(preId) {
            const el = document.getElementById(preId);
            if (!el) {
                console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
                alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
                return;
            }

            const raw = el.textContent || '';

            // Build clipboard according to selected align mode
            const prepared = buildClipboardFromMode(raw);
            copyPlainText(prepared).catch(() => console.warn('Clipboard copy may have failed.'));

            // In-page insert: still insert raw so first line is at caret and others align
            processAndInsertText(raw);

            alert('Clipboard ready. Move to your target editor and paste.');
        }
        function refreshSnippets(buttonId) {
            const column = document.getElementById('snippet-column');
            column.innerHTML = '';

            const data = snippetData[buttonId];
            if (!data) return;

            data.snippets.forEach((snippet, index) => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet movement';
                const preId = `snippet-${buttonId}-${index}`;
                const pre = document.createElement('pre');
                pre.id = preId;
                pre.contentEditable = true;
                pre.style.display = 'none';
                const parts = [];
                parts.push(snippet.textPython);
                pre.textContent = parts.join('\n') + '\n';

                snippetDiv.appendChild(pre);

                const button = document.createElement('button');
                // emoji slightly larger via CSS class
                button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
                button.style.backgroundColor = snippet.color;
                button.style.color = '#ffffff';
                button.title = snippet.buttonText; // keep accessible label

                console.log('removed the message to please insert caret first');

                // Click inserts into textarea and prepares clipboard with proper indentation for external paste
                button.addEventListener('click', () => copySnippetWithLineInsert(preId));

                snippetDiv.appendChild(button);
                column.appendChild(snippetDiv);
            });
        }

        // Insert multiline text with caret-relative indentation into #t on paste; expose processAndInsertText.
        (function () {
            const ta = document.getElementById('t');

            function processAndInsertText(inputText) {
                if (!inputText) return; // nothing to do

                const value = ta.value;
                const selStart = ta.selectionStart;
                const selEnd = ta.selectionEnd;

                // find start index of the current line where the caret is (or selection start)
                const lineStart = value.lastIndexOf('\n', Math.max(0, selStart - 1)) + 1;
                const caretColumn = selStart - lineStart; // number of characters from line start to caret

                // build the padding string (spaces). If you prefer tabs, change this.
                const pad = ' '.repeat(caretColumn);

                // Normalize newlines in inputText (handles CRLF)
                const pastedLines = inputText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');

                // If the user is replacing a selection, the first pasted line should be inserted at selStart,
                // so we do not prefix the first line. Only subsequent lines get the pad prefixed.
                for (let i = 1; i < pastedLines.length; i++) {
                    pastedLines[i] = pad + pastedLines[i];
                }

                const toInsert = pastedLines.join('\n');

                // Replace selection with our processed text
                const newValue = value.slice(0, selStart) + toInsert + value.slice(selEnd);
                ta.value = newValue;

                // compute new caret position: place caret just after the inserted content
                const newCaretPos = selStart + toInsert.length;
                ta.setSelectionRange(newCaretPos, newCaretPos);
                // optional: trigger input event if other code listens for it
                ta.dispatchEvent(new Event('input', { bubbles: true }));
            }

            ta.addEventListener('paste', function (ev) {
                // get plain text from clipboard
                const clipboardText = (ev.clipboardData || window.clipboardData).getData('text');
                ev.preventDefault(); // we'll insert our processed text
                processAndInsertText(clipboardText);
            });

            // insert multiline text into the textarea at caret position with proper indentation
            window.processAndInsertText = processAndInsertText;
        })();

        document.addEventListener('DOMContentLoaded', () => refreshSnippets(1));

        // SPIKE editor caret column support
        (function () {
            const bc = new BroadcastChannel('spike-caret-column');
            bc.onmessage = (ev) => {
                if (typeof ev.data === 'number') {
                    window.__spikeCaretColumn = ev.data;
                    console.log('SPIKE caret column updated:', ev.data);
                }
            };
        })();

        // Shared channel to receive caret column from the SPIKE editor tab (same-origin only)
        const spikeChannel = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('spike-caret') : null;
        window.__spikeCaretCol = null;
        if (spikeChannel) {
            spikeChannel.onmessage = (ev) => {
                try {
                    const data = ev.data;
                    if (data && data.type === 'caret' && typeof data.column === 'number') {
                        window.__spikeCaretCol = Math.max(0, data.column | 0);
                        console.log('Received SPIKE caret column:', window.__spikeCaretCol);
                    }
                } catch (e) { /* ignore */ }
            };
        }

        // Cross-tab caret receiver via postMessage from SPIKE tab
        window.__spikeCaretCol = null;
        window.addEventListener('message', (ev) => {
            try {
                // Optional: restrict to known origin
                // if (ev.origin !== 'https://spike.legoeducation.com') return;
                const d = ev.data;
                if (d && d.type === 'spike-caret' && typeof d.column === 'number') {
                    window.__spikeCaretCol = Math.max(0, d.column | 0);
                    console.log('postMessage spike caret:', window.__spikeCaretCol, 'from', ev.origin);
                }
            } catch (_) { }
        });

        // Helper to open SPIKE page with opener preserved (no noopener)
        document.getElementById('open-spike').addEventListener('click', () => {
            const url = 'https://spike.legoeducation.com/prime/project';
            // Ensure opener is available by omitting noopener
            window.open(url, 'spike-editor-tab', 'noopener=no');
        });
    </script>
</body>

</html>