<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Spike</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 2px;
            background-color: #ffffff;
            color: #000000;
            margin: 0;
        }

        .left-column {
            position: fixed;
            top: 0;
            left: 0;
            width: 80px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            background-color: #f5f5f5;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
        }

        .emoji-block {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding-top: 12px;
            height: 100%;
            overflow-y: auto;
            width: 100%;
        }

        .emoji-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .emoji-container button {
            font-size: 32px;
            cursor: pointer;
            border: none;
            background: none;
            transition: transform 0.15s ease, filter 0.15s ease;
        }

        .emoji-container button:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-label {
            margin-top: 1px;
            font-size: 12px;
            color: black;
            text-align: center;
            width: 70px;
            word-wrap: break-word;
        }

        .snippet-column {
            margin-left: 80px;
            padding: 0px 12px 12px 12px;
        }

        .snippet {
            border: none;
            border-radius: 8px;
            padding: 6px;
            margin: 8px 0;
            background-color: transparent;
            width: 100%;
            box-sizing: border-box;
        }

        .snippet button {
            cursor: pointer;
            padding: 8px 12px;
            font-size: 14px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.12);
            color: #ffffff;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.12s ease, filter 0.12s ease;
        }

        .snippet button:hover {
            transform: scale(1.04);
            filter: brightness(110%);
        }

        .snippet .emoji {
            font-size: 1.3em;
            line-height: 1;
        }

        .snippet .label {
            font-size: 1em;
        }

        .release-info {
            text-align: center;
            margin-top: 400px;
            padding: 20px;
            font-size: 12px;
            color: #666;
            border-top: 1px solid #eee;
        }

        .emoji-container .color-circle {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: transform 0.15s ease, filter 0.15s ease;
            font-size: 0; /* Remove any text content */
        }

        .emoji-container .color-circle:hover {
            transform: scale(1.08);
            filter: brightness(110%);
        }

        .emoji-container .blue-circle { background-color: #0066FF !important; }
        .emoji-container .light-blue-circle { background-color: #87CEEB !important; }
        .emoji-container .red-circle { background-color: #CC0000 !important; }
        .emoji-container .pink-circle { background-color: #FF69B4 !important; }
        .emoji-container .purple-circle { background-color: #8A2BE2 !important; }
        .emoji-container .yellow-circle { background-color: #FFD700 !important; }
        .emoji-container .dark-yellow-circle { background-color: #DAA520 !important; }
        .emoji-container .green-circle { background-color: #32CD32 !important; }
    </style>
</head>
<body>
    <div class="left-column">
        <div class="emoji-block">
            <div class="emoji-container"><button class="color-circle purple-circle" onclick="refreshSnippets(1)"></button>
                <div class="emoji-label">Demos</div>
            </div>
        </div>
    </div>
    <div class="snippet-column" id="snippet-column">
        <!-- Snippets will be dynamically inserted here -->
    </div>
    <div class="snippet-column">
        <div class="release-info" id="release-info">
            ¬© 2024 Spike Editor - Loading release info...
        </div>
    </div>
    <script>
        const snippetData = {
            1: {  // Demos
                snippets: [
                    {
                        id: "fn1",
                        buttonText: 'Line Follower Bang Bang (main)',
                        emoji: 'üßø',
                        color: '#8A2BE2',
                        textPython: `
########################################################################
# ü§ñ Main - Line Follower Bang Bang (Main)
########################################################################
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

    # set steering to 50% of maximum
    steering = 50

    # set movement speed to 20%
    speed = int(0.2 * 1100)

    # set sleep seconds to 40 milliseconds 
    sleep_milliseconds = 40

    for i in range (200):
        if color_sensor.color(port.F) == color.BLUE and color_sensor.color(port.F) != -1:
            motor_pair.move(motor_pair.PAIR_1, -steering, velocity=speed)
            sleep_ms(sleep_milliseconds)
        else:
            motor_pair.move(motor_pair.PAIR_1, steering, velocity=speed)
            sleep_ms(sleep_milliseconds)`
                    },
                    {
                        id: "fn2",
                        buttonText: 'Line Follower Proportional (Class)',
                        emoji: 'üßø',
                        color: '#8A2BE2',
                        textPython: `
########################################################################
# ü§ñ LineFollower - Proportional (Class)
########################################################################
class LineFollower:
    """    
    This robot class teaches your robot how to follow a line by using a light sensor 
    to see the difference between dark and light surfaces, then automatically steering 
    the wheels to stay on the line - just like a self-driving car!


    Example:
            
            # Create a robot object from the LineFollower class.

            robot = LineFollower(target_light=60, speed=180, kp=6.8)
            
            
            # Repeat until returning to the start point.

            while not (motor.relative_position(port.D) > 1000):

    
                # Follow a line using proportional corrections.

                await robot.follow_line()

    Args:
        target_light (int): The "center line" value - the light level robot tries to stay on.
            Think of this as the target the robot aims for.
            Defaults to 60.
        speed (int): How fast the robot moves forward while following the line.
            Defaults to 180.
        kp (float): The "rubber band strength" - how hard the robot steers back to center.
            Like Force = Mass √ó Acceleration: bigger kp = stronger force = sharper turns.
            Defaults to 6.8.
           

    Note:
        - Target_light: Find this by measuring light over the edge between dark and light areas
        - Higher speeds work for competition, but start with slower speeds for learning  
        - kp is like a rubber band connecting your robot to the center line:
          ‚Ä¢ Small kp = weak rubber band = gentle corrections
          ‚Ä¢ Large kp = strong rubber band = sharp corrections
          ‚Ä¢ Too large kp = robot oscillates (wobbles back and forth)
        """

    def __init__(self, target_light: int = 70, speed: int = 140, kp: float = 6.5) -> None:
        self.target_light = target_light
        self.speed = speed
        self.kp = kp
        self.iteration = 0
    
    async def follow_line(self):
        """Execute one iteration of line following behavior.
        
        This method performs a single iteration of the line following control loop.
        It reads the light sensor value, calculates steering correction using proportional
        control, and adjusts motor speeds accordingly. The parent code is responsible
        for calling this method repeatedly in a loop.
        
        The control algorithm works by:
        1. Reading light reflection from the color sensor
        2. Calculating error as (target_light - current_light)
        3. Applying proportional gain (kp) to generate steering correction
        4. Adjusting left/right motor speeds based on correction
        
        Motor behavior:
        - Left motor (port C): Runs in reverse direction (-speed)
        - Right motor (port D): Runs in forward direction (+speed)
        - Steering correction added or subtracted from left, added or subtracted from right
        
        Returns:
            None: Executes one control iteration and returns.
        
        Raises:
            Usually no errors, but the robot might have problems if the motors or sensors stop working properly.
        
        Note:
            - Color sensor must be set to reflection mode before calling this method.
            - Parent code should call this method repeatedly in a loop for continuous line following
            - Each call performs one sensor reading and motor speed adjustment
            - Debug information is printed each iteration showing sensor readings and calculated motor speeds
        
        Example:
            # Parent code controls the loop
            line_follower = LineFollower(60, 180, 6.8)
            
            # Run for specific number of iterations
            for i in range(100):
                await line_follower.follow_line()
                await sleep_ms(100)  # Add delay between iterations
            
            # Or run indefinitely
            while True:
                await line_follower.follow_line()
                await sleep_ms(100)
        """
        # Turn On Butterfly For 2 Seconds
        #light_matrix.show_image(light_matrix.IMAGE_BUTTERFLY) # pyright: ignore[reportUndefinedVariable]
        #sleep(2)        # pyright: ignore[reportUndefinedVariable] # Perform one line following iteration
        
        light_intensity = color_sensor.reflection(port.F) # pyright: ignore[reportUndefinedVariable]
        steering_correction = self.kp * (self.target_light - light_intensity)
        
        left_speed = self.speed + steering_correction
        right_speed = self.speed - steering_correction
        
        motor.run(port.C, -int(left_speed)) # pyright: ignore[reportUndefinedVariable]
        motor.run(port.D, int(right_speed)) # pyright: ignore[reportUndefinedVariable]
        
        self.debug_print(self.iteration, self.target_light, self.speed, self.kp, light_intensity, 
                         steering_correction, left_speed, right_speed)
        
        self.iteration += 1

    def debug_print(self, iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed):
        """Debug printing utility"""
        print("Iteration: {:3d} | Target_Light: {:3d} | Speed: {:3d} | KP: {:6.2f} | Steering_Correction: {:6.2f} | Left_Speed: {:6.2f} | Right_Speed: {:6.2f}".format(
            iteration, target_light, speed, kp, light_intensity, steering_correction, left_speed, right_speed))
        

    async def stop_motors(self):
        """Stop both motors"""
        motor.stop(port.C) # pyright: ignore[reportUndefinedVariable]
        motor.stop(port.D) # pyright: ignore[reportUndefinedVariable]`        
            }       ,
                    {
                        id: "fn3",
                        buttonText: 'Line Follower Proportional (Main)',
                        emoji: 'üßø',
                        color: '#8A2BE2',
                        textPython: `
########################################################################
# ü§ñ Main - Line Follower Proportional
########################################################################
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)
    motor.reset_relative_position(port.D, 0)

    # Create a robot object from the LineFollower class.
    robot = LineFollower(target_light=70, speed=140, kp=6.5)

    # Repeat until returning to the start point.

        # Follow a line using proportional corrections.
        # Hint the robot class has a follow_line method
        # robot calls the follow_line method with 
        # await robot.follow_line()

        # if a hand is near stop and wait for 2 seconds
        `
                    },
                    {
                        id: "fn3",
                        buttonText: 'Line Follower Proportional (Hint)',
                        emoji: 'üßø',
                        color: '#8A2BE2',
                        textPython: `# Line Follower
import runloop, time, sys, motor_pair, motor, force_sensor
import color, color_sensor, distance_sensor
from hub import light, light_matrix, port, sound
from time import sleep, sleep_ms

DEGREES_PER_CM = 21
DEGREES_PER_INCH = 53
MM_PER_INCH = 25.4

########################################################################
# ‚òÄÔ∏è is_near - Function or condition to check if something is close
########################################################################
def is_near(distance_threshold=100): # 100mm (4 inches) minimum

    distance = distance_sensor.distance(port.F)

    if distance == -1:
        print("Warning: Distance sensor not detecting anything")
        return False

    print ("Distance {:5.2f} cm {:6.2f} inches ".format(distance / 10, distance / 25.4))

    return distance < distance_threshold

########################################################################
# ü§ñ LineFollower - Proportional (Class)
########################################################################
class LineFollower:

    def __init__(self, target_light: int = 70, speed: int = 140, kp: float = 6.5) -> None:
        self.target_light = target_light
        self.speed = speed
        self.kp = kp
        self.iteration = 0

    async def follow_line(self):

        light_intensity = color_sensor.reflection(port.B) 
        steering_correction = self.kp * (self.target_light - light_intensity)

        left_speed = self.speed + steering_correction
        right_speed = self.speed - steering_correction

        motor.run(port.C, -int(left_speed)) 
        motor.run(port.D, int(right_speed)) 

        self.iteration += 1

########################################################################
# ü§ñ Main - Follow a line using proportional corrections. 
########################################################################
async def main():
    motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)
    motor.reset_relative_position(port.D, 0)

    # Create a robot object from the LineFollower class.
    robot = LineFollower(target_light=70, speed=140, kp=6.5)

    # Repeat until returning to the start point.

        # Call the follow_line method from the robot object
        # await robot.follow_line()

        # if a hand is near stop and wait for 2 seconds

runloop.run(main())
sys.exit()
`
                    },                    
                    {
                        id: "fn4",
                        buttonText: 'Line Counter',
                        emoji: 'üßø',
                        color: '#8A2BE2',
                        textPython: `# Line Counter
import runloop, sys, motor_pair, runloop 
import color, color_sensor, distance_sensor 
from hub import light, light_matrix, port, sound 
from time import sleep, sleep_ms
from runloop import run 

DEGREES_PER_CM = 21
DEGREES_PER_INCH = 53
MM_PER_INCH = 25.4

########################################################################
# üõë Constants - Connect two motors together so they work as a team
########################################################################
motor_pair.pair(motor_pair.PAIR_1, port.C, port.D)

########################################################################
# üõë Constants - Color code numbers represent different colors to the robot
########################################################################
blue = 3
yellow = 7
red = 9

########################################################################
# üõë Variables - count how many times we see each color
########################################################################
red_count = 0
yellow_count = 0
blue_count = 0

########################################################################
# üõë Variable Remember the last color seen 
#             so we don't count the same color twice in a row
########################################################################
last_color = None

########################################################################
# üõë Variable This is like a stop sign for our program 
#              when it's True, everything stops
########################################################################
should_stop = False

########################################################################
# ü§ñ Function Watches for blue colors
#             The "async" means it can work at the same time as other functions
########################################################################
async def check_blue():
    # Use "global" to access variables from outside this function
    global blue_count, last_color, should_stop

    while not should_stop:
        # Ask the color sensor what color it sees right now
        current_color = color_sensor.color(port.F)

        if current_color == blue and last_color != blue:
            light.color(light.POWER, current_color)
            last_color = blue
            blue_count += 1

        await runloop.sleep_ms(100)

########################################################################
# ü§ñ Function Watches for yellow colors (works just like check_blue)
########################################################################
async def check_yellow():
    # *** challenge 2 ***: replace pass with the code from check_blue then change to yellow
    pass

########################################################################
# ü§ñ Function Watches for red colors (works just like the others)
########################################################################
async def check_red():
    # *** challenge 3 ***: replace pass with the code from check_blue then change to red
    pass

########################################################################
# ü§ñ Function Watches for someone waving their hand near the robot
########################################################################
async def check_hand_wave():
    global blue_count, yellow_count, should_stop

    while not should_stop:
        # Check how far away the nearest object is (in millimeters)
        distance = distance_sensor.distance(port.B)

        # If something is close (less than 14cm or 140mm away) and the sensor is working
        if distance != -1 and distance < 140:
            motor_pair.stop(motor_pair.PAIR_1)
            # Tell all other functions to stop
            should_stop = True
            # Show our final results - how many of each color we counted
            # *** challenge 4 *** replace print to use the hub to display the counts
            print("Blue count:{:2d}".format (blue_count))
            print("Yellow count:{:2d}".format (yellow_count))
            print("Red count:{:2d}".format (red_count))
            # Exit this loop
            break

        # Wait a bit before checking distance again
        await runloop.sleep_ms(100)

########################################################################
# ü§ñ Main Count blue, yellow and red line along a square
########################################################################
async def main():
    
    # Start the motors moving forward at normal speed
    motor_pair.move(motor_pair.PAIR_1, 0)

    # *** challenge 1 *** move the robot along a 60cm square while checking colors

    # Run all our checking functions at the same time
    # It's like having multiple people doing different jobs simultaneously
    run(check_blue(), check_yellow(), check_red(), check_hand_wave())

runloop.run(main())
sys.exit()
   `
                    },

                ]
            },   // Functions
            
        };

        document.addEventListener('DOMContentLoaded', () => {
            refreshSnippets(1);
            fetchGitHubRelease();
        });
    </script>
    <script>
        // Utility functions (from utils.js)
        function refreshSnippets(buttonId) {
            const column = document.getElementById('snippet-column');
            column.innerHTML = '';
        
            const data = snippetData[buttonId];
            if (!data) return;
        
            data.snippets.forEach((snippet, index) => {
                const snippetDiv = document.createElement('div');
                snippetDiv.className = 'snippet movement';
        
                const preId = `snippet-${buttonId}-${index}`;
                const pre = document.createElement('pre');
                pre.id = preId;
                pre.contentEditable = true;
                pre.style.display = 'none';
        
                // build the copy text: include function definition (if any), comment, then python body
                const parts = [];
                parts.push(snippet.textPython);
                pre.textContent = parts.join('\n') + '\n';
        
                //console.log(`BUILDING PRE HERE AS: ${pre.textContent}`);
        
                snippetDiv.appendChild(pre);
        
                const button = document.createElement('button');
                // emoji slightly larger via CSS class
                button.innerHTML = `<span class="emoji">${snippet.emoji}</span><span class="label">${snippet.buttonText}</span>`;
                button.style.backgroundColor = snippet.color;
                button.style.color = (buttonId === 4 || buttonId === 5 || buttonId === 6) ? '#000000' : '#ffffff';
                button.title = snippet.buttonText; // keep accessible label
        
                button.addEventListener('click', () => copySnippetWithLineInsert(preId));
        
                snippetDiv.appendChild(button);
                column.appendChild(snippetDiv);
            });
        }
        
        function copySnippetWithLineInsert(preId) {
            const el = document.getElementById(preId);
            if (!el) {
                console.warn(`copySnippetWithLineInsert: element with id ${preId} not found`);
                alert('Snippet not available to copy. Try clicking the left-column emoji to reload snippets.');
                return;
            }
        
            const text = el.textContent || '';
        
            // do not add additional indentation here; keep text as authored
            const textToCopy = text;
        
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).catch(() => fallbackCopy(textToCopy));
            } else {
                fallbackCopy(textToCopy);
            }
        }
        
        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'absolute';
            textarea.style.left = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            try { document.execCommand('copy'); } catch (e) { console.error('fallback copy failed', e); }
            document.body.removeChild(textarea);
        }
        
        async function fetchGitHubRelease() {
            /**
             * Fetches the latest release information from the GitHub repository and updates the UI.
             * 
             * This function makes an API call to the GitHub releases endpoint to retrieve the latest
             * release data for the Spike-Editor repository. It updates the release-info element with
             * the fetched release name or falls back to a default version if the request fails.
             * 
             * @async
             * @function fetchGitHubRelease
             * @returns {Promise<void>} A promise that resolves when the release information has been fetched and displayed
             * @throws {Error} Throws an error if the GitHub API request fails or returns a non-ok response
             * 
             * @example
             * // Call the function to update release information
             * await fetchGitHubRelease();
             * 
             * @description
             * - Makes a GET request to 'https://api.github.com/repos/edking21/Spike-Editor/releases/latest'
             * - On success: Updates the 'release-info' element with "¬© 2025 Spike Editor - Release {release.name}"
             * - On failure: Falls back to "¬© 2025 Spike Editor - Release v1.0.0" and logs a warning
             * - Requires an HTML element with id 'release-info' to exist in the DOM
             */
            try {
                const response = await fetch('https://api.github.com/repos/edking21/Spike-Editor/releases/latest');
                if (response.ok) {
                    const release = await response.json();
                    const releaseInfo = document.getElementById('release-info');
                    releaseInfo.textContent = `¬© 2025 Spike Editor - Release ${release.name}`;
                } else {
                    throw new Error('Failed to fetch release');
                }
            } catch (error) {
                console.warn('Could not fetch GitHub release:', error);
                const releaseInfo = document.getElementById('release-info');
                releaseInfo.textContent = '¬© 2025 Spike Editor - Release v1.0.0';
            }
        }
        
    </script>
</body>
</html>
